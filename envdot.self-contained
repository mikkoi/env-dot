#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Env/Dot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot;
  use strict;
  use warnings;
  
  # We define our own import routine because
  # this is the point (when `use Env::Dot` is called)
  # when we do our magic.
  
  {
      no warnings 'redefine';    ## no critic [TestingAndDebugging::ProhibitNoWarnings]
  
      sub import {
          load_vars();
          return;
      }
  }
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use Env::Dot::Functions qw(
    get_dotenv_vars
    interpret_dotenv_filepath_var
    get_envdot_filepaths_var_name
  );
  
  use constant {
      OPTION_FILE_TYPE         => q{file:type},
      OPTION_FILE_TYPE_PLAIN   => q{plain},
      OPTION_FILE_TYPE_SHELL   => q{shell},
      DEFAULT_OPTION_FILE_TYPE => q{shell},
      DEFAULT_ENVDOT_FILEPATHS => q{.env},
      INDENT                   => q{    },
  };
  
  =pod
  
  =begin stopwords
  
  dotenv env envdot
  
  =end stopwords
  
  =head1 STATUS
  
  Package L<Env::Dot> is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot;
  
      print $ENV{'VAR_DEFINED_IN_DOTENV_FILE'};
  
  =head1 DESCRIPTION
  
  More flexibility in how you manage and use your F<.env> file.
  
  B<Attn. Existing environment variables always take precedence to dotenv variables!>
  A dotenv variable (variable from a file) does not overwrite
  an existing environment variable. This is by design because
  a dotenv file is to augment the environment, not to replace it.
  
  This means that you can override a variable in `.env` file by creating
  its counterpart in the environment. For instance:
  
      unset VAR
      echo "VAR='Good value'" >> .env
      perl -e 'use Env::Dot; print "VAR:$ENV{VAR}\n";'
      # VAR:Good value
      VAR='Better value'; export VAR
      perl -e 'use Env::Dot; print "VAR:$ENV{VAR}\n";'
      # VAR:Better value
  
  =head2 Features
  
  =over 8
  
  =item If no B<.env> file is present, then do nothing
  
  By default, Env::Dot will do nothing if there is no
  B<.env> file.
  You can also configure Env::Dot to emit an alarm
  or break execution, if you want.
  
  =item Specify other dotenv files with path
  
  If your B<.env> file is located in another path,
  not the current working directory,
  you can use the environment variable
  B<ENVDOT_FILEPATHS> to tell where your dotenv file is located.
  You can specify several file paths; just separate
  them by B<:>. Env::Dot will load the files in the B<reverse order>,
  starting from the last. This is the same ordering as used in B<PATH> variable:
  the first overrules the following ones, that is, when reading from the last path
  to the first path, if same variable is present in more than one file, the later
  one replaces the one already read.
  
  For example, if you have the following directory structure:
  
      project-root
      | .env
      + - sub-project
        | .env
  
  and you specify B<ENVDOT_FILEPATHS=project-root/sub-project/.env:project-root/.env>,
  then the variables in file B<project-root/.env> will get replaced
  by the more specific variables in B<project-root/sub-project/.env>
  
  N.B. The ordering has changed in version 0.0.9.
  
  =item Support different types of .env files
  
  Unix Shell I<source> command compatible dotenv files use double or single quotation marks
  (B<"> or B<'>) to define a variable which has spaces. But, for instance,
  Docker compatible F<.env> files do not use quotation marks. The variable's
  value begins with B<=> sign and ends with linefeed.
  
  You can specify in the dotenv file itself - by using meta commands -
  which type of file it is.
  
  =item Use executable B<envdot> to bring the variables into your shell
  
  The executable is distributed together with Env::Dot package.
  It is in the directory I<script>.
  
      eval "$(envdot)"
  
  N.B. If your B<.env> file(s) contain variables which need interpolating,
  for example, to combine their value from other variables or execute a command
  to produce their value, you have to use the B<envdot> program.
  B<Env::Dot> does not do any interpolating. It cannot because that would involve
  running the variable in the shell context.
  
  =back
  
  =head2 DotEnv File Meta Commands
  
  The B<var:> commands affect only the subsequent variable definition.
  If there is another B<envdot> command, the second overwrites the first
  and default values are applied again.
  
  =over 8
  
  =item read:from_parent
  
  By setting this option to B<true>, B<Env::Dot> or B<envdot> command
  will search for F<.env> files in the file system tree upwards.
  It will load the first F<.env> file it finds from
  the current directory upwards to root.
  
  Using B<read:from_parent> will only find and read
  one B<.env> file in a parent directory.
  If you want to chain the B<.env> files,
  they all must set B<read:from_parent> - except the top one.
  
  This functionality can be useful in situations where you have
  parallel projects which share common environment variables
  in one F<.env> file in a parent directory.
  
  If there is no parent F<.env> file, Env::Dot will break execution
  and give an error.
  
  By default this setting is off.
  
  =item read:allow_missing_parent
  
  When using option B<read:from_parent>, if the parent F<.env> file does not exist,
  by default Env::Dot will emit an error and break execution.
  In some situations, it might be normal that a parent F<.env> file
  could be missing. Turn on option B<read:allow_missing_parent> if you
  do not want an error in that case.
  
  By default this setting is off.
  
  =item file:type
  
  Changes how B<Env::Dot> reads lines below from this commands. Default is:
  
      # envdot (file:type=shell)
      VAR="value"
  
  Other possible value of B<file:type> is:
  
      # envdot (file:type=plain)
      VAR=My var value
  
  =item var:allow_interpolate
  
  By default, when writing variable definitions for the shell,
  every variable is treated as static and surrounded with
  single quotation marks B<'> in Unix shell which means
  shell will read the variable content as is.
  By setting this to B<1> or B<true>, you allow shell
  to interpolate.
  This meta command is only useful when running B<envdot> command
  to create variable definitions for B<eval> command to read.
  
      # envdot (var:allow_interpolate)
      DYNAMIC_VAR="$(pwd)/${ANOTHER_VAR}"
  
  =back
  
  =head1 DEPENDENCIES
  
  No external dependencies outside Perl's standard distribution.
  
  =head1 FUNCTIONS
  
  No functions exported to the calling namespace.
  
  =head2 load_vars
  
  Load variables from F<.env> file or files in environment variable
  B<ENVDOT_FILEPATHS>.
  
  =cut
  
  sub load_vars {
      my @dotenv_filepaths;
      if ( exists $ENV{ get_envdot_filepaths_var_name() } ) {
          @dotenv_filepaths = interpret_dotenv_filepath_var( $ENV{ get_envdot_filepaths_var_name() } );
      }
      else {
          if ( -f DEFAULT_ENVDOT_FILEPATHS ) {
              @dotenv_filepaths = (DEFAULT_ENVDOT_FILEPATHS);    # The CLI parameter
          }
      }
  
      my @vars = get_dotenv_vars(@dotenv_filepaths);
      my %new_env;
  
      # Populate new env with the dotenv variables.
      foreach my $var (@vars) {
          ### no critic [Variables::RequireLocalizedPunctuationVars]
          $new_env{ $var->{'name'} } = $var->{'value'};
      }
      foreach my $var_name ( sort keys %ENV ) {
          $new_env{$var_name} = $ENV{$var_name};
      }
  
      # We need to replace the current %ENV, not change individual values.
      ## no critic [Variables::RequireLocalizedPunctuationVars]
      %ENV = %new_env;
      return \%ENV;
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Env::Assert> will verify that you certainly have those environmental
  variables you need. It also has an executable which can perform the check
  in the beginning of a B<docker> container run.
  
  L<Dotenv> is another package which implements functionality to use
  F<.env> files in Perl.
  
  =cut
ENV_DOT

$fatpacked{"Env/Dot/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT_FUNCTIONS';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot::Functions;
  use strict;
  use warnings;
  use Data::Dumper;
  
  use Cwd qw( abs_path );
  use File::Spec;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
    get_dotenv_vars
    interpret_dotenv_filepath_var
    get_envdot_filepaths_var_name
  );
  our %EXPORT_TAGS = (
      'all' => [
          qw(
            get_dotenv_vars
            interpret_dotenv_filepath_var
            get_envdot_filepaths_var_name
          )
      ],
  );
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use constant {
      OPTION_FILE_TYPE                         => q{file:type},
      OPTION_FILE_TYPE_PLAIN                   => q{plain},
      OPTION_FILE_TYPE_SHELL                   => q{shell},
      DEFAULT_OPTION_FILE_TYPE                 => q{shell},
      OPTION_READ_FROM_PARENT                  => q{read:from_parent},
      DEFAULT_OPTION_READ_FROM_PARENT          => 0,
      OPTION_READ_ALLOW_MISSING_PARENT         => q{read:allow_missing_parent},
      DEFAULT_OPTION_READ_ALLOW_MISSING_PARENT => 0,
  };
  
  my %DOTENV_OPTIONS = (
      OPTION_READ_FROM_PARENT()          => 1,
      OPTION_READ_ALLOW_MISSING_PARENT() => 1,
      'file:type'                        => 1,
      'var:allow_interpolate'            => 1,
  );
  
  =pod
  
  =for stopwords envdot env
  
  =head1 STATUS
  
  Package L<Env::Dot> is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot::Functions qw( get_dotenv_vars interpret_dotenv_filepath_var );
  
  =head1 DESCRIPTION
  
  This package just contains functions for use
  in the main package L<Env::Dot> and in
  the command line tool B<envdot>.
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 get_dotenv_vars()
  
  Return all variables from the F<.env> file
  as a list of hashes (name/value pairs).
  This list is created in the same order the variables
  are read from the files and may therefore contain
  the same variable several times.
  
  The files, however, are read in reversed order, just like
  paths in variable B<PATH> are used.
  
  =cut
  
  sub get_dotenv_vars {
      my @dotenv_filepaths = @_;
  
      my @vars;
      foreach my $filepath ( reverse @dotenv_filepaths ) {
          if ( -f $filepath ) {
              push @vars, _read_dotenv_file_recursively($filepath);
          }
          else {
              carp "No file found: '$filepath'";
          }
      }
      return @vars;
  }
  
  =head2 interpret_dotenv_filepath_var( $filepaths )
  
  Return a list of file paths.
  
  =cut
  
  sub interpret_dotenv_filepath_var {    ## no critic (Subroutines::RequireArgUnpacking)
      return split qr{:}msx, $_[0];
  }
  
  # Private subroutines
  
  sub _read_dotenv_file_recursively {
      my ($filepath) = @_;
      $filepath = abs_path($filepath);
      my @rows       = _read_dotenv_file($filepath);
      my %r          = _interpret_dotenv(@rows);
      my @these_vars = @{ $r{'vars'} };
      if ( $r{'opts'}->{ OPTION_READ_FROM_PARENT() } ) {
          my $parent_filepath = _get_parent_dotenv_filepath($filepath);
          if ($parent_filepath) {
              unshift @these_vars, _read_dotenv_file_recursively($parent_filepath);
          }
          elsif ( !$r{'opts'}->{ OPTION_READ_ALLOW_MISSING_PARENT() } ) {
              croak "Error: No parent .env file. Child .env: $filepath";
          }
      }
      return @these_vars;
  }
  
  # Follow directory hierarchy upwards until you find a .env file.
  # If you don't, return undef.
  # Otherwise return the path.
  sub _get_parent_dotenv_filepath {
      my ($current_filepath) = @_;
  
      my ( $volume, $directories, $file ) = File::Spec->splitpath($current_filepath);
      my ($parent_path)     = abs_path( File::Spec->catdir( $directories, File::Spec->updir ) );
      my ($parent_filepath) = abs_path( File::Spec->catdir( $parent_path, '.env' ) );
      while ( !-f $parent_filepath ) {
          return if ( $parent_path eq File::Spec->rootdir );
          ( $volume, $directories, $file ) = File::Spec->splitpath($parent_filepath);
          $parent_path     = abs_path( File::Spec->catdir( $directories, File::Spec->updir ) );
          $parent_filepath = abs_path( File::Spec->catdir( $parent_path, '.env' ) );
      }
      return $parent_filepath;
  }
  
  sub _interpret_dotenv {
      my (@rows) = @_;
      my %options = (
          OPTION_READ_FROM_PARENT()          => DEFAULT_OPTION_READ_FROM_PARENT,
          OPTION_READ_ALLOW_MISSING_PARENT() => DEFAULT_OPTION_READ_ALLOW_MISSING_PARENT,
          'file:type'                        => DEFAULT_OPTION_FILE_TYPE,
          'var:allow_interpolate'            => 0,
      );    # Options related to reading the file. Applied as they are read.
            # my %vars;
      my @vars;
      foreach (@rows) {
          ## no critic (ControlStructures::ProhibitCascadingIfElse)
          ## no critic (RegularExpressions::ProhibitComplexRegexes)
          if (
              # This is envdot meta command
              # The var:<value> options can only apply to one subsequent var row.
              m{
              ^ [[:space:]]{0,} [#]{1}
              [[:space:]]{1,} envdot [[:space:]]{1,}
              [(] (?<opts> [^)]{0,}) [)]
              [[:space:]]{0,} $
              }msx
            )
          {
              my $opts = _interpret_opts( $LAST_PAREN_MATCH{opts} );
              _validate_opts($opts);
              $options{'var:allow_interpolate'} = 0;
              foreach ( keys %{$opts} ) {
                  $options{$_} = $opts->{$_};
              }
          }
          elsif (
              # This is comment row
              m{
                  ^ [[:space:]]{0,} [#]{1} .* $
              }msx
            )
          {
              1;
          }
          elsif (
              # This is empty row
              m{
                  ^ [[:space:]]{0,} $
              }msx
            )
          {
              1;
          }
          elsif (
              # This is env var description
              m{
                  ^ (?<name> [^=]{1,}) = (?<value> .*) $
              }msx
            )
          {
              my ( $name, $value ) = ( $LAST_PAREN_MATCH{name}, $LAST_PAREN_MATCH{value} );
              if ( $options{'file:type'} eq OPTION_FILE_TYPE_SHELL ) {
                  if (
                      $value =~ m{
                      ^
                      ['"]{1} (?<value> .*) ["']{1}  # Get value from between quotes
                      (?: [;] [[:space:]]{0,} export [[:space:]]{1,} $name)?  # optional
                      [[:space:]]{0,}  # optional whitespace at the end
                      $
                  }msx
                    )
                  {
                      ($value) = $LAST_PAREN_MATCH{value};
                  }
  
                  # "export" can also be at the start. Only for TYPE_SHELL
                  if ( $name =~ m{^ [[:space:]]{0,} export [[:space:]]{1,} }msx ) {
                      $name =~ m{
                          ^
                          [[:space:]]{0,} export [[:space:]]{1,} (?<name> .*)
                          $
                      }msx;
                      $name = $LAST_PAREN_MATCH{name};
                  }
              }
              elsif ( $options{'file:type'} eq OPTION_FILE_TYPE_PLAIN ) {
                  1;
              }
              my %opts = ( allow_interpolate => $options{'var:allow_interpolate'}, );
              push @vars, { name => $name, value => $value, opts => \%opts, };
              $options{'var:allow_interpolate'} = 0;
          }
          else {
              carp "Uninterpretable row: $_";
          }
      }
      return opts => \%options, vars => \@vars;
  }
  
  sub _validate_opts {
      my ($opts) = @_;
      foreach my $key ( keys %{$opts} ) {
          if ( !exists $DOTENV_OPTIONS{$key} ) {
              croak "Unknown envdot option: $key";
          }
      }
      return;
  }
  
  sub _interpret_opts {
      my ($opts_str) = @_;
      my @opts = split qr{
          [[:space:]]{0,} [,] [[:space:]]{0,}
          }msx, $opts_str;
      my %opts;
      foreach (@opts) {
          ## no critic (ControlStructures::ProhibitPostfixControls)
          my ( $key, $val ) = split qr/=/msx;
          $val        = $val // 1;
          $val        = 1 if ( $val eq 'true'  || $val eq 'True' );
          $val        = 0 if ( $val eq 'false' || $val eq 'False' );
          $opts{$key} = $val;
      }
      return \%opts;
  }
  
  sub _read_dotenv_file {
      my ($filepath) = @_;
      open my $fh, q{<}, $filepath or croak "Cannot open file '$filepath'";
      my @dotenv_rows;
      while (<$fh>) { chomp; push @dotenv_rows, $_; }
      close $fh or croak "Cannot close file '$filepath'";
      return @dotenv_rows;
  }
  
  =head2 get_envdot_filepaths_var_name
  
  Return the name of the environment variable
  which user can use to specify the paths of .env files.
  
  =cut
  
  sub get_envdot_filepaths_var_name {
      return q{ENVDOT_FILEPATHS};
  }
  
  1;
ENV_DOT_FUNCTIONS

$fatpacked{"Env/Dot/ScriptFunctions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT_SCRIPTFUNCTIONS';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot::ScriptFunctions;
  use strict;
  use warnings;
  use Data::Dumper;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
    convert_variables_into_commands
  );
  our %EXPORT_TAGS = ( 'all' => [qw( convert_variables_into_commands )], );
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use constant {
      OPTION_FILE_TYPE         => q{file:type},
      OPTION_FILE_TYPE_PLAIN   => q{plain},
      OPTION_FILE_TYPE_SHELL   => q{shell},
      DEFAULT_OPTION_FILE_TYPE => q{shell},
  };
  
  my %DOTENV_OPTIONS = (
      'file:type'             => 1,
      'var:allow_interpolate' => 1,
  );
  
  my %VAR_OUTPUT = (
      q{sh}   => \&_convert_var_to_sh,
      q{csh}  => \&_convert_var_to_csh,
      q{fish} => \&_convert_var_to_fish,
  );
  
  =pod
  
  =for stopwords envdot env
  
  =head1 STATUS
  
  Package L<Env::Dot> is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot::ScriptFunctions qw( convert_variables_into_commands );
  
  =head1 DESCRIPTION
  
  This package just contains functions for use
  in the main package L<Env::Dot> and in
  the command line tool B<envdot>.
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 convert_variables_into_commands()
  
  # Return all variables from the F<.env> file
  # as a list of hashes (name/value pairs).
  # This list is created in the same order the variables
  # are read from the files and may therefore contain
  # the same variable several times.
  
  =cut
  
  sub convert_variables_into_commands {
      my ( $shell, @vars ) = @_;
      my $out = q{};
      foreach my $var (@vars) {
          $out .= _convert_variable( $shell, $var );
          $out .= "\n";
      }
      return $out;
  }
  
  # Private subroutines
  
  sub _convert_variable {
      my ( $shell, $var ) = @_;
      if ( exists $VAR_OUTPUT{$shell} ) {
          return &{ $VAR_OUTPUT{$shell} }($var);
      }
      else {
          croak "Unknown shell: $shell";
      }
  }
  
  sub _convert_var_to_sh {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      if ($want_export) {
          return sprintf "%s=$quote%s$quote; export %s", $name, $value, $name;
      }
      else {
          return sprintf "%s=$quote%s$quote", $name, $value;
      }
  }
  
  sub _convert_var_to_csh {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      if ($want_export) {
          return sprintf "setenv %s $quote%s$quote", $name, $value;
      }
      else {
          return sprintf "set %s $quote%s$quote", $name, $value;
      }
  }
  
  sub _convert_var_to_fish {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      return sprintf "set -e %s; set -x -U %s $quote%s$quote", $name, $name, $value;
  }
  
  1;
ENV_DOT_SCRIPTFUNCTIONS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

## no critic (ControlStructures::ProhibitPostfixControls)
## no critic (ValuesAndExpressions::ProhibitConstantPragma)
use strict;
use warnings;
use open ':std', IO => ':encoding(UTF-8)';

# ABSTRACT: Read .env file and turn its content into environment variables for different shells.

# PODNAME: envdot

our $VERSION = '0.012'; # VERSION: generated by DZP::OurPkgVersion

use English      qw( -no_match_vars );                   # Avoids regex performance penalty in perl 5.18 and earlier
use Getopt::Long qw( :config auto_version auto_help );
use Carp;
use Pod::Usage;

use Env::Dot::Functions qw(
  get_dotenv_vars
  interpret_dotenv_filepath_var
  get_envdot_filepaths_var_name
);
use Env::Dot::ScriptFunctions qw( convert_variables_into_commands );

local $OUTPUT_AUTOFLUSH = 1;

use constant {
    DEFAULT_OPTION_DOTENV_FILENAME => '.env',
    DEFAULT_OPTION_SHELL           => q{sh},
    DEFAULT_OPTION_READ_FROM_STDIN => 0,
};

my %SHELL_ALTERNATIVES = (
    sh   => 'sh',
    bash => 'sh',
    dash => 'sh',
    ksh  => 'sh',
    csh  => 'csh',
    tcsh => 'csh',
    fish => 'fish',
);

my $man             = 0;
my $export          = 1;
my $shell           = $SHELL_ALTERNATIVES{ $ENV{SHELL} } // DEFAULT_OPTION_SHELL;
my $dotenv_filepath = DEFAULT_OPTION_DOTENV_FILENAME;
my $read_from_stdin = DEFAULT_OPTION_READ_FROM_STDIN;
GetOptions(
    'man'        => \$man,
    'export!'    => \$export,
    'shell|s=s'  => \$shell,
    'dotenv|e=s' => \$dotenv_filepath,
    ''           => \$read_from_stdin,    ## no critic (ValuesAndExpressions::ProhibitEmptyQuotes)
) or pod2usage(2);
pod2usage( -exitval => 0, -verbose => 2 ) if $man;

sub main {
    my $var_name = get_envdot_filepaths_var_name();
    my @dotenv_filepaths;
    if ( exists $ENV{$var_name} ) {
        @dotenv_filepaths = interpret_dotenv_filepath_var( $ENV{$var_name} );
    }
    elsif ($read_from_stdin) {
    }
    else {
        if ( !-f $dotenv_filepath ) {
            carp "No file found: '$dotenv_filepath'";
            return 1;
        }
        @dotenv_filepaths = ($dotenv_filepath);    # The CLI parameter
    }

    my @vars;
    foreach my $dotenv_filepath ( reverse @dotenv_filepaths ) {
        push @vars, get_dotenv_vars($dotenv_filepath);
    }
    $_->{'opts'}->{'export'} = $export foreach (@vars);

    print {*STDOUT} convert_variables_into_commands( $shell, @vars )
      or croak 'Cannot print variables to STDOUT';

    return 0;
}

exit main(@ARGV);

__END__

=pod

=encoding UTF-8

=head1 NAME

envdot - Read .env file and turn its content into environment variables for different shells.

=head1 VERSION

version 0.012

=head1 SYNOPSIS

envdot [options]

    eval `envdot`

Options:
    --help
    --man
    --version
    --export --no-export
    --shell -s
    --dotenv -e

=head2 CLI interface without dependencies

The F<envdot> command is also available
as a self contained executable.
You can download it and run it as it is without
additional installation of CPAN packages.
Of course, you still need Perl, but Perl comes with any
normal Linux installation.

This can be convenient if you want to, for instance,
include F<envdot> in a docker container build.

    curl -LSs -o envdot https://raw.githubusercontent.com/mikkoi/env-dot/main/envdot.self-contained
    chmod +x ./envdot

=head1 DESCRIPTION

B<envdot> reads your F<.env> file and converts it
into environment variable commands suitable for
different shells (shell families): B<sh>, B<csh> and B<fish>.

F<.env> files can be written in different flavors.
B<envdot> supports the often used B<sh> compatible flavor and
the B<docker> flavor which are not compatible with each other.

If you have several F<.env> files, you can read them in at one go
with the help of the environment variable B<ENVDOT_FILEPATHS>.
Separate the full paths with 'B<:>' character.

Env::Dot will load the files in the B<reverse order>,
starting from the last. This is the same ordering as used in B<PATH> variable:
the first overrules the following ones, that is, when reading from the last path
to the first path, if same variable is present in more than one file, the later
one replaces the one already read.

If you have set the variable ENVDOT_FILEPATHS, then B<envdot> will use that.
Otherwise, it uses the command line parameter.
If no parameter, then default value is used. Default is the file
F<.env> in the current directory.

=head1 NAME

envdot - Read .env file and turn its content into environment variables for different shells.

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--version>

Prints the version and exits.

=item B<--export>, B<--no-export>

Write commands to set variables for local shell or for exporting them.
You usually want to export the variables
to all subsequent programs and subshells, i.e.
make them into I<environment variables>.

Default: export

=item B<-s>, B<--shell>

Which shell (family) are you using? Supported: sh, csh, fish.

Default: sh

=item B<-e>, B<--dotenv>

Path to F<.env> file.

Default: current directory F<.env>

=back

=head1 EXAMPLES

    eval `envdot --no-export --shell csh`

    eval `envdot --dotenv subdir/.env`

    ENVDOT_FILEPATHS='../.env:subdir/.env:.env' eval `envdot`

=head1 DEPENDENCIES

No external dependencies outside Perl's standard distribution.

=head1 SEE ALSO

L<Env::Assert> will verify that you certainly have those environmental
variables you need. It also has an executable which can, for example,
be used to perform the check in the beginning of a B<docker> container run.

L<Dotenv> is another package which implements functionality to use
F<.env> files in Perl.

L<shdotenv|https://github.com/ko1nksm/shdotenv> is a project to provide dotenv
for shells with support for POSIX-compliant and multiple .env file syntax.

=head1 AUTHOR

Mikko Koivunalho <mikkoi@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2023 by Mikko Koivunalho.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
