#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Env/Dot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot;
  use strict;
  use warnings;
  
  # We define our own import routine because
  # this is the point (when `use Env::Dot` is called)
  # when we do our magic.
  
  {
      no warnings 'redefine';    ## no critic [TestingAndDebugging::ProhibitNoWarnings]
  
      sub import {
          load_vars();
          return;
      }
  }
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use Env::Dot::Functions qw(
      get_dotenv_vars
      interpret_dotenv_filepath_var
      get_envdot_filepaths_var_name
      extract_error_msg
      create_error_msg
  );
  
  use constant {
      OPTION_FILE_TYPE         => q{file:type},
      OPTION_FILE_TYPE_PLAIN   => q{plain},
      OPTION_FILE_TYPE_SHELL   => q{shell},
      DEFAULT_OPTION_FILE_TYPE => q{shell},
      DEFAULT_ENVDOT_FILEPATHS => q{.env},
      INDENT                   => q{    },
  };
  
  =pod
  
  =begin stopwords
  
  dotenv env envdot
  
  =end stopwords
  
  =head1 STATUS
  
  Package L<Env::Dot> is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot;
  
      print $ENV{'VAR_DEFINED_IN_DOTENV_FILE'};
  
  =head1 DESCRIPTION
  
  More flexibility in how you manage and use your F<.env> file.
  
  B<Attn. Existing environment variables always take precedence to dotenv variables!>
  A dotenv variable (variable from a file) does not overwrite
  an existing environment variable. This is by design because
  a dotenv file is to augment the environment, not to replace it.
  
  This means that you can override a variable in `.env` file by creating
  its counterpart in the environment. For instance:
  
      unset VAR
      echo "VAR='Good value'" >> .env
      perl -e 'use Env::Dot; print "VAR:$ENV{VAR}\n";'
      # VAR:Good value
      VAR='Better value'; export VAR
      perl -e 'use Env::Dot; print "VAR:$ENV{VAR}\n";'
      # VAR:Better value
  
  =head2 Features
  
  =over 8
  
  =item If no B<.env> file is present, then do nothing
  
  By default, Env::Dot will do nothing if there is no
  B<.env> file.
  You can also configure Env::Dot to emit an alarm
  or break execution, if you want.
  
  =item Specify other dotenv files with path
  
  If your B<.env> file is located in another path,
  not the current working directory,
  you can use the environment variable
  B<ENVDOT_FILEPATHS> to tell where your dotenv file is located.
  You can specify several file paths; just separate
  them by B<:>. Env::Dot will load the files in the B<reverse order>,
  starting from the last. This is the same ordering as used in B<PATH> variable:
  the first overrules the following ones, that is, when reading from the last path
  to the first path, if same variable is present in more than one file, the later
  one replaces the one already read.
  
  For example, if you have the following directory structure:
  
      project-root
      | .env
      + - sub-project
        | .env
  
  and you specify B<ENVDOT_FILEPATHS=project-root/sub-project/.env:project-root/.env>,
  then the variables in file B<project-root/.env> will get replaced
  by the more specific variables in B<project-root/sub-project/.env>
  
  N.B. The ordering has changed in version 0.0.9.
  
  =item Support different types of .env files
  
  Unix Shell I<source> command compatible dotenv files use double or single quotation marks
  (B<"> or B<'>) to define a variable which has spaces. But, for instance,
  Docker compatible F<.env> files do not use quotation marks. The variable's
  value begins with B<=> sign and ends with linefeed.
  
  You can specify in the dotenv file itself - by using meta commands -
  which type of file it is.
  
  =item Use executable B<envdot> to bring the variables into your shell
  
  The executable is distributed together with Env::Dot package.
  It is in the directory I<script>.
  
      eval "$(envdot)"
  
  N.B. If your B<.env> file(s) contain variables which need interpolating,
  for example, to combine their value from other variables or execute a command
  to produce their value, you have to use the B<envdot> program.
  B<Env::Dot> does not do any interpolating. It cannot because that would involve
  running the variable in the shell context.
  
  =back
  
  =head2 DotEnv File Meta Commands
  
  The B<var:> commands affect only the subsequent variable definition.
  If there is another B<envdot> command, the second overwrites the first
  and default values are applied again.
  
  =over 8
  
  =item read:from_parent
  
  By setting this option to B<true>, B<Env::Dot> or B<envdot> command
  will search for F<.env> files in the file system tree upwards.
  It will load the first F<.env> file it finds from
  the current directory upwards to root.
  
  Using B<read:from_parent> will only find and read
  one B<.env> file in a parent directory.
  If you want to chain the B<.env> files,
  they all must set B<read:from_parent> - except the top one.
  
  This functionality can be useful in situations where you have
  parallel projects which share common environment variables
  in one F<.env> file in a parent directory.
  
  If there is no parent F<.env> file, Env::Dot will break execution
  and give an error.
  
  By default this setting is off.
  
  =item read:allow_missing_parent
  
  When using option B<read:from_parent>, if the parent F<.env> file does not exist,
  by default Env::Dot will emit an error and break execution.
  In some situations, it might be normal that a parent F<.env> file
  could be missing. Turn on option B<read:allow_missing_parent> if you
  do not want an error in that case.
  
  By default this setting is off.
  
  =item file:type
  
  Changes how B<Env::Dot> reads lines below from this commands. Default is:
  
      # envdot (file:type=shell)
      VAR="value"
  
  Other possible value of B<file:type> is:
  
      # envdot (file:type=plain)
      VAR=My var value
  
  =item var:allow_interpolate
  
  By default, when writing variable definitions for the shell,
  every variable is treated as static and surrounded with
  single quotation marks B<'> in Unix shell which means
  shell will read the variable content as is.
  By setting this to B<1> or B<true>, you allow shell
  to interpolate.
  This meta command is only useful when running B<envdot> command
  to create variable definitions for B<eval> command to read.
  
      # envdot (var:allow_interpolate)
      DYNAMIC_VAR="$(pwd)/${ANOTHER_VAR}"
  
  =back
  
  =head1 DEPENDENCIES
  
  No external dependencies outside Perl's standard distribution.
  
  =head1 FUNCTIONS
  
  No functions exported to the calling namespace.
  
  =head2 load_vars
  
  Load variables from F<.env> file or files in environment variable
  B<ENVDOT_FILEPATHS>.
  
  =cut
  
  sub load_vars {
      my @dotenv_filepaths;
      if ( exists $ENV{ get_envdot_filepaths_var_name() } ) {
          @dotenv_filepaths = interpret_dotenv_filepath_var( $ENV{ get_envdot_filepaths_var_name() } );
      }
      else {
          if ( -f DEFAULT_ENVDOT_FILEPATHS ) {
              @dotenv_filepaths = (DEFAULT_ENVDOT_FILEPATHS);    # The CLI parameter
          }
      }
  
      my @vars;
      eval { @vars = get_dotenv_vars(@dotenv_filepaths); 1; } or do {
          my $e = $EVAL_ERROR;
          my ($err, $l, $fp) = extract_error_msg($e);
          croak 'Error: ' . $err . ($l ? qq{ line $l} : q{}) . ($fp ? qq{ file '$fp'} : q{})
      };
      my %new_env;
  
      # Populate new env with the dotenv variables.
      foreach my $var (@vars) {
          $new_env{ $var->{'name'} } = $var->{'value'};
      }
      foreach my $var_name ( sort keys %ENV ) {
          $new_env{$var_name} = $ENV{$var_name};
      }
  
      # We need to replace the current %ENV, not change individual values.
      ## no critic [Variables::RequireLocalizedPunctuationVars]
      %ENV = %new_env;
      return \%ENV;
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Env::Assert> will verify that you certainly have those environmental
  variables you need. It also has an executable which can perform the check
  in the beginning of a B<docker> container run.
  
  L<Dotenv> and L<ENV::Util|https://metacpan.org/pod/ENV::Util>
  are packages which also implement functionality to use
  F<.env> files in Perl.
  
  L<Config::ENV> and L<Config::Layered::Source::ENV> provide other means
  to configure application with the help of environment variables.
  
  =cut
ENV_DOT

$fatpacked{"Env/Dot/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT_FUNCTIONS';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot::Functions;
  use strict;
  use warnings;
  use Data::Dumper;
  
  use Cwd qw( abs_path );
  use English qw( -no_match_vars );
  use File::Spec;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
      get_dotenv_vars
      interpret_dotenv_filepath_var
      get_envdot_filepaths_var_name
      extract_error_msg
      create_error_msg
  );
  our %EXPORT_TAGS = (
      'all' => [
          qw(
              get_dotenv_vars
              interpret_dotenv_filepath_var
              get_envdot_filepaths_var_name
              extract_error_msg
              create_error_msg
          )
      ],
  );
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use constant {
      OPTION_FILE_TYPE                         => q{file:type},
      OPTION_FILE_TYPE_PLAIN                   => q{plain},
      OPTION_FILE_TYPE_SHELL                   => q{shell},
      DEFAULT_OPTION_FILE_TYPE                 => q{shell},
      OPTION_READ_FROM_PARENT                  => q{read:from_parent},
      DEFAULT_OPTION_READ_FROM_PARENT          => 0,
      OPTION_READ_ALLOW_MISSING_PARENT         => q{read:allow_missing_parent},
      DEFAULT_OPTION_READ_ALLOW_MISSING_PARENT => 0,
  };
  
  my %DOTENV_OPTIONS = (
      OPTION_READ_FROM_PARENT()          => 1,
      OPTION_READ_ALLOW_MISSING_PARENT() => 1,
      'file:type'                        => 1,
      'var:allow_interpolate'            => 1,
  );
  
  =pod
  
  =for stopwords envdot env filepath filepaths
  
  =head1 STATUS
  
  Package L<Env::Dot> is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot::Functions qw( get_dotenv_vars interpret_dotenv_filepath_var );
      # or
      use Env::Dot::Functions ':all';
  
  =head1 DESCRIPTION
  
  This package just contains functions for use
  in the main package L<Env::Dot> and in
  the command line tool B<envdot>.
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 get_dotenv_vars(@)
  
  Return all variables from the F<.env> file
  as a list of hashes (name/value pairs).
  This list is created in the same order the variables
  are read from the files and may therefore contain
  the same variable several times.
  
  The files, however, are read in reversed order, just like
  paths in variable B<PATH> are used.
  
  Arguments:
  
  =over 8
  
  =item * filepaths, list of dotenv filepaths.
  
  =back
  
  If a file does not exist, we break the execution.
  
  =cut
  
  sub get_dotenv_vars {
      my (@dotenv_filepaths) = @_;
  
      my @vars;
      foreach my $filepath ( reverse @dotenv_filepaths ) {
          if ( -f $filepath ) {
              push @vars, _read_dotenv_file_recursively($filepath);
          }
          else {
              my ($err) = "File not found: '$filepath'";
              croak create_error_msg($err);
          }
      }
      return @vars;
  }
  
  =head2 interpret_dotenv_filepath_var( $filepaths )
  
  Return a list of file paths.
  
  =cut
  
  sub interpret_dotenv_filepath_var {    ## no critic (Subroutines::RequireArgUnpacking)
      return split qr{:}msx, $_[0];
  }
  
  =head2 get_envdot_filepaths_var_name
  
  Return the name of the environment variable
  which user can use to specify the paths of .env files.
  
  =cut
  
  sub get_envdot_filepaths_var_name {
      return q{ENVDOT_FILEPATHS};
  }
  
  # Private subroutines
  
  sub _read_dotenv_file_recursively {
      my ($filepath) = @_;
      $filepath = abs_path($filepath);
      my @rows       = _read_dotenv_file($filepath);
      local $EVAL_ERROR = undef;
      my %r          = eval { _interpret_dotenv(@rows); };
      if($EVAL_ERROR) {
          my $e = $EVAL_ERROR;
          my ($err, $line) = extract_error_msg($e);
          croak create_error_msg($err, $line, $filepath);
      }
      my @these_vars = @{ $r{'vars'} };
      if ( $r{'opts'}->{ OPTION_READ_FROM_PARENT() } ) {
          my $parent_filepath = _get_parent_dotenv_filepath($filepath);
          if ($parent_filepath) {
              unshift @these_vars, _read_dotenv_file_recursively($parent_filepath);
          }
          elsif ( !$r{'opts'}->{ OPTION_READ_ALLOW_MISSING_PARENT() } ) {
              my ($err) = "No parent .env file found for child file '$filepath'";
              croak create_error_msg($err);
          }
      }
      return @these_vars;
  }
  
  # Follow directory hierarchy upwards until you find a .env file.
  # If you don't, return undef.
  # Otherwise return the path.
  sub _get_parent_dotenv_filepath {
      my ($current_filepath) = @_;
  
      my ( $volume, $directories, $file ) = File::Spec->splitpath($current_filepath);
      my ($parent_path)     = abs_path( File::Spec->catdir( $directories, File::Spec->updir ) );
      my ($parent_filepath) = abs_path( File::Spec->catdir( $parent_path, '.env' ) );
      while ( !-f $parent_filepath ) {
          return if ( $parent_path eq File::Spec->rootdir );
          ( $volume, $directories, $file ) = File::Spec->splitpath($parent_filepath);
          $parent_path     = abs_path( File::Spec->catdir( $directories, File::Spec->updir ) );
          $parent_filepath = abs_path( File::Spec->catdir( $parent_path, '.env' ) );
      }
      return $parent_filepath;
  }
  
  sub _interpret_dotenv {
      my (@rows) = @_;
      my %options = (
          OPTION_READ_FROM_PARENT()          => DEFAULT_OPTION_READ_FROM_PARENT,
          OPTION_READ_ALLOW_MISSING_PARENT() => DEFAULT_OPTION_READ_ALLOW_MISSING_PARENT,
          'file:type'                        => DEFAULT_OPTION_FILE_TYPE,
          'var:allow_interpolate'            => 0,
      );    # Options related to reading the file. Applied as they are read.
      my @vars;
      my $row_num = 1;
      foreach (@rows) {
          ## no critic (ControlStructures::ProhibitCascadingIfElse)
          ## no critic (RegularExpressions::ProhibitComplexRegexes)
          if (
              # This is envdot meta command
              # The var:<value> options can only apply to one subsequent var row.
              m{
              ^ [[:space:]]{0,} [#]{1}
              [[:space:]]{1,} envdot [[:space:]]{1,}
              [(] (?<opts> [^)]{0,}) [)]
              [[:space:]]{0,} $
              }msx
            )
          {
              my $opts = _interpret_opts( $LAST_PAREN_MATCH{opts} );
              local $EVAL_ERROR = undef;
              eval { _validate_opts($opts); 1; } or do {
                  my $e = $EVAL_ERROR;
                  my ($err) = extract_error_msg($e);
                  croak create_error_msg($err, $row_num);
              };
              $options{'var:allow_interpolate'} = 0;
              foreach ( keys %{$opts} ) {
                  $options{$_} = $opts->{$_};
              }
          }
          elsif (
              # This is comment row
              m{
                  ^ [[:space:]]{0,} [#]{1} .* $
              }msx
            )
          {
              1;
          }
          elsif (
              # This is empty row
              m{
                  ^ [[:space:]]{0,} $
              }msx
            )
          {
              1;
          }
          elsif (
              # This is env var description
              m{
                  ^ (?<name> [^=]{1,}) = (?<value> .*) $
              }msx
            )
          {
              my ( $name, $value ) = ( $LAST_PAREN_MATCH{name}, $LAST_PAREN_MATCH{value} );
              if ( $options{'file:type'} eq OPTION_FILE_TYPE_SHELL ) {
                  if (
                      $value =~ m{
                      ^
                      ['"]{1} (?<value> .*) ["']{1}  # Get value from between quotes
                      (?: [;] [[:space:]]{0,} export [[:space:]]{1,} $name)?  # optional
                      [[:space:]]{0,}  # optional whitespace at the end
                      $
                  }msx
                    )
                  {
                      ($value) = $LAST_PAREN_MATCH{value};
                  }
  
                  # "export" can also be at the start. Only for TYPE_SHELL
                  if ( $name =~ m{^ [[:space:]]{0,} export [[:space:]]{1,} }msx ) {
                      $name =~ m{
                          ^
                          [[:space:]]{0,} export [[:space:]]{1,} (?<name> .*)
                          $
                      }msx;
                      $name = $LAST_PAREN_MATCH{name};
                  }
              }
              elsif ( $options{'file:type'} eq OPTION_FILE_TYPE_PLAIN ) {
                  1;
              }
              my %opts = ( allow_interpolate => $options{'var:allow_interpolate'}, );
              push @vars, { name => $name, value => $value, opts => \%opts, };
              $options{'var:allow_interpolate'} = 0;
          }
          else {
              carp "Uninterpretable row: $_";
          }
          $row_num++;
      }
      return opts => \%options, vars => \@vars;
  }
  
  sub _validate_opts {
      my ($opts) = @_;
      foreach my $key ( keys %{$opts} ) {
          if ( !exists $DOTENV_OPTIONS{$key} ) {
              croak create_error_msg( "Unknown envdot option: '$key'" );
          }
      }
      return;
  }
  
  sub _interpret_opts {
      my ($opts_str) = @_;
      my @opts = split qr{ [[:space:]]{0,} [,] [[:space:]]{0,} }msx, $opts_str;
      my %opts;
      foreach (@opts) {
          ## no critic (ControlStructures::ProhibitPostfixControls)
          my ( $key, $val ) = split qr/=/msx;
          $val        = $val // 1;
          $val        = 1 if ( $val eq 'true'  || $val eq 'True' );
          $val        = 0 if ( $val eq 'false' || $val eq 'False' );
          $opts{$key} = $val;
      }
      return \%opts;
  }
  
  sub _read_dotenv_file {
      my ($filepath) = @_;
      open my $fh, q{<}, $filepath or croak "Error: Cannot open file '$filepath'";
      my @dotenv_rows;
      while (<$fh>) { chomp; push @dotenv_rows, $_; }
      # local $INPUT_RECORD_SEPARATOR = undef;
      # my @dotenv_rows = <$fh>;
      # chomp @dotenv_rows;
      close $fh or croak "Error: Cannot close file '$filepath'";
      return @dotenv_rows;
  }
  
  # Error messages:
  # Message structure:
  # <msg>! [line <num>] [file <filepath>]
  
  =head2 extract_error_msg
  
  Extract the elements of error message (exception): err, line and filepath.
  
  =cut
  
  sub extract_error_msg {
      my ($msg) = @_;
      if( ! $msg ) {
          croak 'Parameter error: missing parameter \'msg\'';
      }
      ## no critic (RegularExpressions::ProhibitComplexRegexes)
      my ($err, $line, $filepath) = $msg =~
          m/^ ([^!]{1,}) \! (?: \s line \s ([[:digit:]]{1,}) (?: \s file \s \'([^']{1,})\' )? )? .* $/msx;
      return $err, $line, $filepath;
  }
  
  =head2 create_error_msg
  
  create an error message (exception) from the three elements: err, line and filepath.
  
  =cut
  
  sub create_error_msg {
      my ($err, $line, $filepath) = @_;
      if( ! $err ) {
          croak 'Parameter error: missing parameter \'err\'';
      }
      if( ! $line && $filepath ) {
          croak 'Parameter error: missing parameter \'line\'';
      }
      return "${err}!"
          . (defined $line ? " line ${line}" : q{})
          . (defined $filepath ? " file '${filepath}'" : q{});
  }
  
  1;
ENV_DOT_FUNCTIONS

$fatpacked{"Env/Dot/ScriptFunctions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT_SCRIPTFUNCTIONS';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot::ScriptFunctions;
  use strict;
  use warnings;
  use Data::Dumper;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
    convert_variables_into_commands
  );
  our %EXPORT_TAGS = ( 'all' => [qw( convert_variables_into_commands )], );
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use constant {
      OPTION_FILE_TYPE         => q{file:type},
      OPTION_FILE_TYPE_PLAIN   => q{plain},
      OPTION_FILE_TYPE_SHELL   => q{shell},
      DEFAULT_OPTION_FILE_TYPE => q{shell},
  };
  
  my %DOTENV_OPTIONS = (
      'file:type'             => 1,
      'var:allow_interpolate' => 1,
  );
  
  my %VAR_OUTPUT = (
      q{sh}   => \&_convert_var_to_sh,
      q{csh}  => \&_convert_var_to_csh,
      q{fish} => \&_convert_var_to_fish,
  );
  
  =pod
  
  =for stopwords envdot env
  
  =head1 STATUS
  
  Package L<Env::Dot> is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot::ScriptFunctions qw( convert_variables_into_commands );
  
  =head1 DESCRIPTION
  
  This package just contains functions for use
  in the main package L<Env::Dot> and in
  the command line tool B<envdot>.
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 convert_variables_into_commands()
  
  # Return all variables from the F<.env> file
  # as a list of hashes (name/value pairs).
  # This list is created in the same order the variables
  # are read from the files and may therefore contain
  # the same variable several times.
  
  =cut
  
  sub convert_variables_into_commands {
      my ( $shell, @vars ) = @_;
      my $out = q{};
      foreach my $var (@vars) {
          $out .= _convert_variable( $shell, $var );
          $out .= "\n";
      }
      return $out;
  }
  
  # Private subroutines
  
  sub _convert_variable {
      my ( $shell, $var ) = @_;
      if ( exists $VAR_OUTPUT{$shell} ) {
          return &{ $VAR_OUTPUT{$shell} }($var);
      }
      else {
          croak "Unknown shell: $shell";
      }
  }
  
  sub _convert_var_to_sh {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      if ($want_export) {
          return sprintf "%s=$quote%s$quote; export %s", $name, $value, $name;
      }
      else {
          return sprintf "%s=$quote%s$quote", $name, $value;
      }
  }
  
  sub _convert_var_to_csh {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      if ($want_export) {
          return sprintf "setenv %s $quote%s$quote", $name, $value;
      }
      else {
          return sprintf "set %s $quote%s$quote", $name, $value;
      }
  }
  
  sub _convert_var_to_fish {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      return sprintf "set -e %s; set -x -U %s $quote%s$quote", $name, $name, $value;
  }
  
  1;
ENV_DOT_SCRIPTFUNCTIONS

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;
  
  use strict;
  no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.77';
  our %Cache;
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my $exports = \@{"$pkg\::EXPORT"};
    # But, avoid creating things if they don't exist, which saves a couple of
    # hundred bytes per package processed.
    my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or $fail && @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or $fail and @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    use Exporter 'import';
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    require Exporter;
    our @ISA = qw(Exporter);  # inherit all of Exporter's methods
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use parent 'Exporter';  # inherit all of Exporter's methods
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces.  Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module.  Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>.  Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
    our @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
    our @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What to Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing.  If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs.  The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced Features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import.  They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT.  If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      our @EXPORT      = qw(A1 A2 A3 A4 A5);
      our @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      our %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
  Note that you cannot use tags in @EXPORT or @EXPORT_OK.
  
  Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting Without Using Exporter's import Method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's
  import method.  The export_to_level
  method looks like:
  
      MyPackage->export_to_level(
  	$where_to_export, $package, @what_to_export
      );
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A.  Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting Without Inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want and complicate the inheritance tree.  To avoid this you can do:
  
    package YourModule;
    use Exporter qw(import);
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->VERSION($value) >>.  This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  For historical reasons, Exporter supplies a C<require_version> method that
  simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
  existed, Exporter would call C<require_version>.
  
  Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9.  For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported.  Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error.  The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported.  If the returned
  list is not empty then an error is generated for each symbol and the
  export fails.  The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    our %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
  may make this a fatal error.
  
  =head2 Generating Combined Tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
   our  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls B<under> 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can be very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal way to never have to think about that is to use
  C<BEGIN> blocks and the simple import method.  So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    use Exporter 'import';
    BEGIN {
      our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  Or if you need to inherit from Exporter:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    BEGIN {
      require Exporter;
      our @ISA = qw(Exporter);  # inherit all of Exporter's methods
      our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately like C<use>, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw(Exporter);
    # or
    use parent qw(Exporter);
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; our @ISA = qw(Exporter); }>
  with the same compile-time effect.  The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime
  vs. compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What Not to Export
  
  You have been warned already in L</Selecting What to Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list.  Do B<not>
  export variable names.  Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw($svar @avar %hvar); # DON'T!
  
  Exporting variables is not a good idea.  They can
  change under the hood, provoking horrible
  effects at-a-distance that are too hard to track
  and to fix.  Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities.  At CPAN, you may find
  a bunch of them.  Some are lighter.  Some
  provide improved APIs and features.  Pick the one
  that fits your needs.  The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software.  You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  our $VERSION = '5.77';
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # Save the old __WARN__ handler in case it was defined
      my $oldwarn = $SIG{__WARN__};
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	# restore it back so proper stacking occurs
  	local $SIG{__WARN__} = $oldwarn;
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak(join("\n", @carp, "Can't continue after import errors"));
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  
  our $VERSION = '0.241';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_; # dies if a loop is detected
      };
  };
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<base>
  
  =item L<parent::versioned>
  
  A fork of L<parent> that provides version checking in parent class modules.
  
  =back
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafal Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-2017 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"x86_64-linux/Data/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATA_DUMPER';
  #
  # Data/Dumper.pm
  #
  # convert perl data structures into perl syntax suitable for both printing
  # and eval
  #
  # Documentation at the __END__
  #
  
  package Data::Dumper;
  
  use strict;
  use warnings;
  
  #$| = 1;
  
  use 5.008_001;
  require Exporter;
  
  use constant IS_PRE_516_PERL => $] < 5.016;
  
  use Carp ();
  
  # Globals people alter.
  our ( $Indent, $Trailingcomma, $Purity, $Pad, $Varname, $Useqq, $Terse, $Freezer,
        $Toaster, $Deepcopy, $Quotekeys, $Bless, $Maxdepth, $Pair, $Sortkeys,
        $Deparse, $Sparseseen, $Maxrecurse, $Useperl );
  
  our ( @ISA, @EXPORT, @EXPORT_OK, $VERSION );
  
  BEGIN {
      $VERSION = '2.183'; # Don't forget to set version and release
                          # date in POD below!
  
      @ISA = qw(Exporter);
      @EXPORT = qw(Dumper);
      @EXPORT_OK = qw(DumperX);
  
      # if run under miniperl, or otherwise lacking dynamic loading,
      # XSLoader should be attempted to load, or the pure perl flag
      # toggled on load failure.
      eval {
          require XSLoader;
          XSLoader::load( 'Data::Dumper' );
          1
      }
      or $Useperl = 1;
  }
  
  my $IS_ASCII  = ord 'A' ==  65;
  
  # module vars and their defaults
  $Indent     = 2         unless defined $Indent;
  $Trailingcomma = 0      unless defined $Trailingcomma;
  $Purity     = 0         unless defined $Purity;
  $Pad        = ""        unless defined $Pad;
  $Varname    = "VAR"     unless defined $Varname;
  $Useqq      = 0         unless defined $Useqq;
  $Terse      = 0         unless defined $Terse;
  $Freezer    = ""        unless defined $Freezer;
  $Toaster    = ""        unless defined $Toaster;
  $Deepcopy   = 0         unless defined $Deepcopy;
  $Quotekeys  = 1         unless defined $Quotekeys;
  $Bless      = "bless"   unless defined $Bless;
  #$Expdepth   = 0         unless defined $Expdepth;
  $Maxdepth   = 0         unless defined $Maxdepth;
  $Pair       = ' => '    unless defined $Pair;
  $Useperl    = 0         unless defined $Useperl;
  $Sortkeys   = 0         unless defined $Sortkeys;
  $Deparse    = 0         unless defined $Deparse;
  $Sparseseen = 0         unless defined $Sparseseen;
  $Maxrecurse = 1000      unless defined $Maxrecurse;
  
  #
  # expects an arrayref of values to be dumped.
  # can optionally pass an arrayref of names for the values.
  # names must have leading $ sign stripped. begin the name with *
  # to cause output of arrays and hashes rather than refs.
  #
  sub new {
    my($c, $v, $n) = @_;
  
    Carp::croak("Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])")
      unless (defined($v) && (ref($v) eq 'ARRAY'));
    $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
  
    my($s) = {
          level      => 0,           # current recursive depth
          indent     => $Indent,     # various styles of indenting
          trailingcomma => $Trailingcomma, # whether to add comma after last elem
          pad        => $Pad,        # all lines prefixed by this string
          xpad       => "",          # padding-per-level
          apad       => "",          # added padding for hash keys n such
          sep        => "",          # list separator
          pair       => $Pair,    # hash key/value separator: defaults to ' => '
          seen       => {},          # local (nested) refs (id => [name, val])
          todump     => $v,          # values to dump []
          names      => $n,          # optional names for values []
          varname    => $Varname,    # prefix to use for tagging nameless ones
          purity     => $Purity,     # degree to which output is evalable
          useqq      => $Useqq,      # use "" for strings (backslashitis ensues)
          terse      => $Terse,      # avoid name output (where feasible)
          freezer    => $Freezer,    # name of Freezer method for objects
          toaster    => $Toaster,    # name of method to revive objects
          deepcopy   => $Deepcopy,   # do not cross-ref, except to stop recursion
          quotekeys  => $Quotekeys,  # quote hash keys
          'bless'    => $Bless,    # keyword to use for "bless"
  #        expdepth   => $Expdepth,   # cutoff depth for explicit dumping
          maxdepth   => $Maxdepth,   # depth beyond which we give up
  	maxrecurse => $Maxrecurse, # depth beyond which we abort
          useperl    => $Useperl,    # use the pure Perl implementation
          sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
          deparse    => $Deparse,    # use B::Deparse for coderefs
          noseen     => $Sparseseen, # do not populate the seen hash unless necessary
         };
  
    if ($Indent > 0) {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    return bless($s, $c);
  }
  
  # Packed numeric addresses take less memory. Plus pack is faster than sprintf
  
  sub format_refaddr {
      require Scalar::Util;
      pack "J", Scalar::Util::refaddr(shift);
  };
  
  #
  # add-to or query the table of already seen references
  #
  sub Seen {
    my($s, $g) = @_;
    if (defined($g) && (ref($g) eq 'HASH'))  {
      my($k, $v, $id);
      while (($k, $v) = each %$g) {
        if (defined $v) {
          if (ref $v) {
            $id = format_refaddr($v);
            if ($k =~ /^[*](.*)$/) {
              $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
                   (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
                   (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
                   (   "\$" . $1 ) ;
            }
            elsif ($k !~ /^\$/) {
              $k = "\$" . $k;
            }
            $s->{seen}{$id} = [$k, $v];
          }
          else {
            Carp::carp("Only refs supported, ignoring non-ref item \$$k");
          }
        }
        else {
          Carp::carp("Value of ref must be defined; ignoring undefined item \$$k");
        }
      }
      return $s;
    }
    else {
      return map { @$_ } values %{$s->{seen}};
    }
  }
  
  #
  # set or query the values to be dumped
  #
  sub Values {
    my($s, $v) = @_;
    if (defined($v)) {
      if (ref($v) eq 'ARRAY')  {
        $s->{todump} = [@$v];        # make a copy
        return $s;
      }
      else {
        Carp::croak("Argument to Values, if provided, must be array ref");
      }
    }
    else {
      return @{$s->{todump}};
    }
  }
  
  #
  # set or query the names of the values to be dumped
  #
  sub Names {
    my($s, $n) = @_;
    if (defined($n)) {
      if (ref($n) eq 'ARRAY') {
        $s->{names} = [@$n];         # make a copy
        return $s;
      }
      else {
        Carp::croak("Argument to Names, if provided, must be array ref");
      }
    }
    else {
      return @{$s->{names}};
    }
  }
  
  sub DESTROY {}
  
  sub Dump {
    return &Dumpxs
      unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl})
              # Use pure perl version on earlier releases on EBCDIC platforms
          || (! $IS_ASCII && $] lt 5.021_010);
    return &Dumpperl;
  }
  
  #
  # dump the refs in the current dumper object.
  # expects same args as new() if called via package name.
  #
  our @post;
  sub Dumpperl {
    my($s) = shift;
    my(@out, $val, $name);
    my($i) = 0;
    local(@post);
  
    $s = $s->new(@_) unless ref $s;
  
    for $val (@{$s->{todump}}) {
      @post = ();
      $name = $s->{names}[$i++];
      $name = $s->_refine_name($name, $val, $i);
  
      my $valstr;
      {
        local($s->{apad}) = $s->{apad};
        $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};
        $valstr = $s->_dump($val, $name);
      }
  
      $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
      my $out = $s->_compose_out($valstr, \@post);
  
      push @out, $out;
    }
    return wantarray ? @out : join('', @out);
  }
  
  # wrap string in single quotes (escaping if needed)
  sub _quote {
      my $val = shift;
      $val =~ s/([\\\'])/\\$1/g;
      return  "'" . $val .  "'";
  }
  
  # Old Perls (5.14-) have trouble resetting vstring magic when it is no
  # longer valid.
  use constant _bad_vsmg => defined &_vstring && (_vstring(~v0)||'') eq "v0";
  
  #
  # twist, toil and turn;
  # and recurse, of course.
  # sometimes sordidly;
  # and curse if no recourse.
  #
  sub _dump {
    my($s, $val, $name) = @_;
    my($out, $type, $id, $sname);
  
    $type = ref $val;
    $out = "";
  
    if ($type) {
  
      # Call the freezer method if it's specified and the object has the
      # method.  Trap errors and warn() instead of die()ing, like the XS
      # implementation.
      my $freezer = $s->{freezer};
      if ($freezer and UNIVERSAL::can($val, $freezer)) {
        eval { $val->$freezer() };
        warn "WARNING(Freezer method call failed): $@" if $@;
      }
  
      require Scalar::Util;
      my $realpack = Scalar::Util::blessed($val);
      my $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
      $id = format_refaddr($val);
  
      # Note: By this point $name is always defined and of non-zero length.
      # Keep a tab on it so that we do not fall into recursive pit.
      if (exists $s->{seen}{$id}) {
        if ($s->{purity} and $s->{level} > 0) {
          $out = ($realtype eq 'HASH')  ? '{}' :
                 ($realtype eq 'ARRAY') ? '[]' :
                 'do{my $o}' ;
          push @post, $name . " = " . $s->{seen}{$id}[0];
        }
        else {
          $out = $s->{seen}{$id}[0];
          if ($name =~ /^([\@\%])/) {
            my $start = $1;
            if ($out =~ /^\\$start/) {
              $out = substr($out, 1);
            }
            else {
              $out = $start . '{' . $out . '}';
            }
          }
        }
        return $out;
      }
      else {
        # store our name
        $s->{seen}{$id} = [ (
            ($name =~ /^[@%]/)
              ? ('\\' . $name )
              : ($realtype eq 'CODE' and $name =~ /^[*](.*)$/)
                ? ('\\&' . $1 )
                : $name
          ), $val ];
      }
      my $no_bless = 0;
      my $is_regex = 0;
      if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
          $is_regex = 1;
          $no_bless = $realpack eq 'Regexp';
      }
  
      # If purity is not set and maxdepth is set, then check depth:
      # if we have reached maximum depth, return the string
      # representation of the thing we are currently examining
      # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)').
      if (!$s->{purity}
        and defined($s->{maxdepth})
        and $s->{maxdepth} > 0
        and $s->{level} >= $s->{maxdepth})
      {
        return qq['$val'];
      }
  
      # avoid recursing infinitely [perl #122111]
      if ($s->{maxrecurse} > 0
          and $s->{level} >= $s->{maxrecurse}) {
          die "Recursion limit of $s->{maxrecurse} exceeded";
      }
  
      # we have a blessed ref
      my ($blesspad);
      if ($realpack and !$no_bless) {
        $out = $s->{'bless'} . '( ';
        $blesspad = $s->{apad};
        $s->{apad} .= '       ' if ($s->{indent} >= 2);
      }
  
      $s->{level}++;
      my $ipad = $s->{xpad} x $s->{level};
  
      if ($is_regex) {
          my $pat;
          my $flags = "";
          if (defined(*re::regexp_pattern{CODE})) {
            ($pat, $flags) = re::regexp_pattern($val);
          }
          else {
            $pat = "$val";
          }
          $pat =~ s <
                       (\\.)           # anything backslash escaped
                     | (\$)(?![)|]|\z) # any unescaped $, except $| $) and end
                     | /               # any unescaped /
                    >
                    {
                        $1 ? $1
                            : $2 ? '${\q($)}'
                            : '\\/'
                    }gex;
          $out .= "qr/$pat/$flags";
      }
      elsif ($realtype eq 'SCALAR' || $realtype eq 'REF'
      || $realtype eq 'VSTRING') {
        if ($realpack) {
          $out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
        }
        else {
          $out .= '\\' . $s->_dump($$val, "\${$name}");
        }
      }
      elsif ($realtype eq 'GLOB') {
        $out .= '\\' . $s->_dump($$val, "*{$name}");
      }
      elsif ($realtype eq 'ARRAY') {
        my($pad, $mname);
        my($i) = 0;
        $out .= ($name =~ /^\@/) ? '(' : '[';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) :
      # omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
          ($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
          ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        for my $v (@$val) {
          $sname = $mname . '[' . $i . ']';
          $out .= $pad . $ipad . '#' . $i
            if $s->{indent} >= 3;
          $out .= $pad . $ipad . $s->_dump($v, $sname);
          $out .= ","
              if $i++ < $#$val
              || ($s->{trailingcomma} && $s->{indent} >= 1);
        }
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
        $out .= ($name =~ /^\@/) ? ')' : ']';
      }
      elsif ($realtype eq 'HASH') {
        my ($k, $v, $pad, $lpad, $mname, $pair);
        $out .= ($name =~ /^\%/) ? '(' : '{';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        $lpad = $s->{apad};
        $pair = $s->{pair};
        ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
      # omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
          ($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
          ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        my $sortkeys = defined($s->{sortkeys}) ? $s->{sortkeys} : '';
        my $keys = [];
        if ($sortkeys) {
          if (ref($s->{sortkeys}) eq 'CODE') {
            $keys = $s->{sortkeys}($val);
            unless (ref($keys) eq 'ARRAY') {
              Carp::carp("Sortkeys subroutine did not return ARRAYREF");
              $keys = [];
            }
          }
          else {
            $keys = [ sort keys %$val ];
          }
        }
  
        # Ensure hash iterator is reset
        keys(%$val);
  
        my $key;
        while (($k, $v) = ! $sortkeys ? (each %$val) :
           @$keys ? ($key = shift(@$keys), $val->{$key}) :
           () )
        {
          my $nk = $s->_dump($k, "");
  
          # _dump doesn't quote numbers of this form
          if ($s->{quotekeys} && $nk =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) {
            $nk = $s->{useqq} ? qq("$nk") : qq('$nk');
          }
          elsif (!$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/) {
            $nk = $1
          }
  
          $sname = $mname . '{' . $nk . '}';
          $out .= $pad . $ipad . $nk . $pair;
  
          # temporarily alter apad
          $s->{apad} .= (" " x (length($nk) + 4))
            if $s->{indent} >= 2;
          $out .= $s->_dump($val->{$k}, $sname) . ",";
          $s->{apad} = $lpad
            if $s->{indent} >= 2;
        }
        if (substr($out, -1) eq ',') {
          chop $out if !$s->{trailingcomma} || !$s->{indent};
          $out .= $pad . ($s->{xpad} x ($s->{level} - 1));
        }
        $out .= ($name =~ /^\%/) ? ')' : '}';
      }
      elsif ($realtype eq 'CODE') {
        if ($s->{deparse}) {
          require B::Deparse;
          my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
          my $pad =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
          $sub    =~ s/\n/$pad/gs;
          $out   .=  $sub;
        }
        else {
          $out .= 'sub { "DUMMY" }';
          Carp::carp("Encountered CODE ref, using dummy placeholder") if $s->{purity};
        }
      }
      else {
        Carp::croak("Can't handle '$realtype' type");
      }
  
      if ($realpack and !$no_bless) { # we have a blessed ref
        $out .= ', ' . _quote($realpack) . ' )';
        $out .= '->' . $s->{toaster} . '()'
          if $s->{toaster} ne '';
        $s->{apad} = $blesspad;
      }
      $s->{level}--;
    }
    else {                                 # simple scalar
  
      my $ref = \$_[1];
      my $v;
      # first, catalog the scalar
      if ($name ne '') {
        $id = format_refaddr($ref);
        if (exists $s->{seen}{$id}) {
          if ($s->{seen}{$id}[2]) {
            $out = $s->{seen}{$id}[0];
            #warn "[<$out]\n";
            return "\${$out}";
          }
        }
        else {
          #warn "[>\\$name]\n";
          $s->{seen}{$id} = ["\\$name", $ref];
        }
      }
      $ref = \$val;
      if (ref($ref) eq 'GLOB') {  # glob
        my $name = substr($val, 1);
        $name =~ s/^main::(?!\z)/::/;
        if ($name =~ /\A(?:[A-Z_a-z][0-9A-Z_a-z]*)?::(?:[0-9A-Z_a-z]+::)*[0-9A-Z_a-z]*\z/ && $name ne 'main::') {
          $sname = $name;
        }
        else {
          local $s->{useqq} = IS_PRE_516_PERL && ($s->{useqq} || $name =~ /[^\x00-\x7f]/) ? 1 : $s->{useqq};
          $sname = $s->_dump(
            $name eq 'main::'
              ? ''
              : $name,
            "",
          );
          $sname = '{' . $sname . '}';
        }
        if ($s->{purity}) {
          my $k;
          local ($s->{level}) = 0;
          for $k (qw(SCALAR ARRAY HASH)) {
            my $gval = *$val{$k};
            next unless defined $gval;
            next if $k eq "SCALAR" && ! defined $$gval;  # always there
  
            # _dump can push into @post, so we hold our place using $postlen
            my $postlen = scalar @post;
            $post[$postlen] = "\*$sname = ";
            local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
            $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
          }
        }
        $out .= '*' . $sname;
      }
      elsif (!defined($val)) {
        $out .= "undef";
      }
      # This calls the XSUB _vstring (if the XS code is loaded). I'm not *sure* if
      # if belongs in the "Pure Perl" implementation. It sort of depends on what
      # was meant by "Pure Perl", as this subroutine already relies Scalar::Util
      # loading, which means that it has an XS dependency. De facto, it's the
      # "Pure Perl" implementation of dumping (which uses XS helper code), as
      # opposed to the C implementation (which calls out to Perl helper code).
      # So in that sense this is fine - it just happens to be a local XS helper.
      elsif (defined &_vstring and $v = _vstring($val)
        and !_bad_vsmg || eval $v eq $val) {
        $out .= $v;
      }
      # However the confusion comes here - if we *can't* find our XS helper, we
      # fall back to this code, which generates different (worse) results. That's
      # better than nothing, *but* it means that if you run the regression tests
      # with Dumper.so missing, the test for "vstrings" fails, because this code
      # here generates a different result. So there are actually "three" different
      # implementations of Data::Dumper (kind of sort of) but we only test two.
      elsif (!defined &_vstring
         and ref $ref eq 'VSTRING' || eval{Scalar::Util::isvstring($val)}) {
        $out .= sprintf "v%vd", $val;
      }
      # \d here would treat "1\x{660}" as a safe decimal number
      elsif ($val =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) { # safe decimal number
        $out .= $val;
      }
      else {                 # string
        if ($s->{useqq} or $val =~ tr/\0-\377//c) {
          # Fall back to qq if there's Unicode
          $out .= qquote($val, $s->{useqq});
        }
        else {
          $out .= _quote($val);
        }
      }
    }
    if ($id) {
      # if we made it this far, $id was added to seen list at current
      # level, so remove it to get deep copies
      if ($s->{deepcopy}) {
        delete($s->{seen}{$id});
      }
      elsif ($name) {
        $s->{seen}{$id}[2] = 1;
      }
    }
    return $out;
  }
  
  #
  # non-OO style of earlier version
  #
  sub Dumper {
    return Data::Dumper->Dump([@_]);
  }
  
  # compat stub
  sub DumperX {
    return Data::Dumper->Dumpxs([@_], []);
  }
  
  #
  # reset the "seen" cache
  #
  sub Reset {
    my($s) = shift;
    $s->{seen} = {};
    return $s;
  }
  
  sub Indent {
    my($s, $v) = @_;
    if (@_ >= 2) {
      if ($v == 0) {
        $s->{xpad} = "";
        $s->{sep} = "";
      }
      else {
        $s->{xpad} = "  ";
        $s->{sep} = "\n";
      }
      $s->{indent} = $v;
      return $s;
    }
    else {
      return $s->{indent};
    }
  }
  
  sub Trailingcomma {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{trailingcomma} = $v), return $s) : $s->{trailingcomma};
  }
  
  sub Pair {
      my($s, $v) = @_;
      @_ >= 2 ? (($s->{pair} = $v), return $s) : $s->{pair};
  }
  
  sub Pad {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{pad} = $v), return $s) : $s->{pad};
  }
  
  sub Varname {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{varname} = $v), return $s) : $s->{varname};
  }
  
  sub Purity {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{purity} = $v), return $s) : $s->{purity};
  }
  
  sub Useqq {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{useqq} = $v), return $s) : $s->{useqq};
  }
  
  sub Terse {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{terse} = $v), return $s) : $s->{terse};
  }
  
  sub Freezer {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{freezer} = $v), return $s) : $s->{freezer};
  }
  
  sub Toaster {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{toaster} = $v), return $s) : $s->{toaster};
  }
  
  sub Deepcopy {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
  }
  
  sub Quotekeys {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
  }
  
  sub Bless {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
  }
  
  sub Maxdepth {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
  }
  
  sub Maxrecurse {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'maxrecurse'} = $v), return $s) : $s->{'maxrecurse'};
  }
  
  sub Useperl {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
  }
  
  sub Sortkeys {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
  }
  
  sub Deparse {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
  }
  
  sub Sparseseen {
    my($s, $v) = @_;
    @_ >= 2 ? (($s->{'noseen'} = $v), return $s) : $s->{'noseen'};
  }
  
  # used by qquote below
  my %esc = (
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  my $low_controls = ($IS_ASCII)
  
                     # This includes \177, because traditionally it has been
                     # output as octal, even though it isn't really a "low"
                     # control
                     ? qr/[\0-\x1f\177]/
  
                       # EBCDIC low controls.
                     : qr/[\0-\x3f]/;
  
  # put a string value in double quotes
  sub qquote {
    local($_) = shift;
    s/([\\\"\@\$])/\\$1/g;
  
    # This efficiently changes the high ordinal characters to \x{} if the utf8
    # flag is on.  On ASCII platforms, the high ordinals are all the
    # non-ASCII's.  On EBCDIC platforms, we don't include in these the non-ASCII
    # controls whose ordinals are less than SPACE, excluded below by the range
    # \0-\x3f.  On ASCII platforms this range just compiles as part of :ascii:.
    # On EBCDIC platforms, there is just one outlier high ordinal control, and
    # it gets output as \x{}.
    my $bytes; { use bytes; $bytes = length }
    s/([^[:ascii:]\0-\x3f])/sprintf("\\x{%x}",ord($1))/ge
      if $bytes > length
  
         # The above doesn't get the EBCDIC outlier high ordinal control when
         # the string is UTF-8 but there are no UTF-8 variant characters in it.
         # We want that to come out as \x{} anyway.  We need is_utf8() to do
         # this.
         || (! $IS_ASCII && utf8::is_utf8($_));
  
    return qq("$_") unless /[[:^print:]]/;  # fast exit if only printables
  
    # Here, there is at least one non-printable to output.  First, translate the
    # escapes.
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    # no need for 3 digits in escape for octals not followed by a digit.
    s/($low_controls)(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
  
    # But otherwise use 3 digits
    s/($low_controls)/'\\'.sprintf('%03o',ord($1))/eg;
  
      # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
    my $high = shift || "";
      if ($high eq "iso8859") {   # Doesn't escape the Latin1 printables
        if ($IS_ASCII) {
          s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
        }
        else {
          my $high_control = utf8::unicode_to_native(0x9F);
          s/$high_control/sprintf('\\%o',ord($1))/eg;
        }
      } elsif ($high eq "utf8") {
  #     Some discussion of what to do here is in
  #       https://rt.perl.org/Ticket/Display.html?id=113088
  #     use utf8;
  #     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      } elsif ($high eq "8bit") {
          # leave it as it is
      } else {
        s/([[:^ascii:]])/'\\'.sprintf('%03o',ord($1))/eg;
        #s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      }
  
    return qq("$_");
  }
  
  sub _refine_name {
      my $s = shift;
      my ($name, $val, $i) = @_;
      if (defined $name) {
        if ($name =~ /^[*](.*)$/) {
          if (defined $val) {
              $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
                (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
                (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
                ( "\$" . $1 ) ;
          }
          else {
            $name = "\$" . $1;
          }
        }
        elsif ($name !~ /^\$/) {
          $name = "\$" . $name;
        }
      }
      else { # no names provided
        $name = "\$" . $s->{varname} . $i;
      }
      return $name;
  }
  
  sub _compose_out {
      my $s = shift;
      my ($valstr, $postref) = @_;
      my $out = "";
      $out .= $s->{pad} . $valstr . $s->{sep};
      if (@{$postref}) {
          $out .= $s->{pad} .
              join(';' . $s->{sep} . $s->{pad}, @{$postref}) .
              ';' .
              $s->{sep};
      }
      return $out;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>
  
  =head1 SYNOPSIS
  
      use Data::Dumper;
  
      # simple procedural interface
      print Dumper($foo, $bar);
  
      # extended usage with names
      print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
  
      # configuration variables
      {
        local $Data::Dumper::Purity = 1;
        eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
      }
  
      # OO usage
      $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
         ...
      print $d->Dump;
         ...
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      eval $d->Dump;
  
  
  =head1 DESCRIPTION
  
  Given a list of scalars or reference variables, writes out their contents in
  perl syntax. The references can also be objects.  The content of each
  variable is output in a single Perl statement.  Handles self-referential
  structures correctly.
  
  The return value can be C<eval>ed to get back an identical copy of the
  original reference structure.  (Please do consider the security implications
  of eval'ing code from untrusted sources!)
  
  Any references that are the same as one of those passed in will be named
  C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
  to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
  notation.  You can specify names for individual values to be dumped if you
  use the C<Dump()> method, or you can change the default C<$VAR> prefix to
  something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
  below.
  
  The default output of self-referential structures can be C<eval>ed, but the
  nested references to C<$VAR>I<n> will be undefined, since a recursive
  structure cannot be constructed using one Perl statement.  You should set the
  C<Purity> flag to 1 to get additional statements that will correctly fill in
  these references.  Moreover, if C<eval>ed when strictures are in effect,
  you need to ensure that any variables it accesses are previously declared.
  
  In the extended usage form, the references to be dumped can be given
  user-specified names.  If a name begins with a C<*>, the output will
  describe the dereferenced type of the supplied reference for hashes and
  arrays, and coderefs.  Output of names will be avoided where possible if
  the C<Terse> flag is set.
  
  In many cases, methods that are used to set the internal state of the
  object will return the object itself, so method calls can be conveniently
  chained together.
  
  Several styles of output are possible, all controlled by setting
  the C<Indent> flag.  See L<Configuration Variables or Methods> below
  for details.
  
  
  =head2 Methods
  
  =over 4
  
  =item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns a newly created C<Data::Dumper> object.  The first argument is an
  anonymous array of values to be dumped.  The optional second argument is an
  anonymous array of names for the values.  The names need not have a leading
  C<$> sign, and must be comprised of alphanumeric characters.  You can begin
  a name with a C<*> to specify that the dereferenced type must be dumped
  instead of the reference itself, for ARRAY and HASH references.
  
  The prefix specified by C<$Data::Dumper::Varname> will be used with a
  numeric suffix if the name for a value is undefined.
  
  Data::Dumper will catalog all references encountered while dumping the
  values. Cross-references (in the form of names of substructures in perl
  syntax) will be inserted at all possible points, preserving any structural
  interdependencies in the original set of values.  Structure traversal is
  depth-first,  and proceeds in order from the first supplied value to
  the last.
  
  =item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns the stringified form of the values stored in the object (preserving
  the order in which they were supplied to C<new>), subject to the
  configuration options below.  In a list context, it returns a list
  of strings corresponding to the supplied values.
  
  The second form, for convenience, simply calls the C<new> method on its
  arguments before dumping the object immediately.
  
  =item I<$OBJ>->Seen(I<[HASHREF]>)
  
  Queries or adds to the internal table of already encountered references.
  You must use C<Reset> to explicitly clear the table if needed.  Such
  references are not dumped; instead, their names are inserted wherever they
  are encountered subsequently.  This is useful especially for properly
  dumping subroutine references.
  
  Expects an anonymous hash of name => value pairs.  Same rules apply for names
  as in C<new>.  If no argument is supplied, will return the "seen" list of
  name => value pairs, in a list context.  Otherwise, returns the object
  itself.
  
  =item I<$OBJ>->Values(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of values that will be dumped.  When
  called without arguments, returns the values as a list.  When called with a
  reference to an array of replacement values, returns the object itself.  When
  called with any other type of argument, dies.
  
  =item I<$OBJ>->Names(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of user supplied names for the values
  that will be dumped.  When called without arguments, returns the names.  When
  called with an array of replacement names, returns the object itself.  If the
  number of replacement names exceeds the number of values to be named, the
  excess names will not be used.  If the number of replacement names falls short
  of the number of values to be named, the list of replacement names will be
  exhausted and remaining values will not be renamed.  When
  called with any other type of argument, dies.
  
  =item I<$OBJ>->Reset
  
  Clears the internal table of "seen" references and returns the object
  itself.
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item Dumper(I<LIST>)
  
  Returns the stringified form of the values in the list, subject to the
  configuration options below.  The values will be named C<$VAR>I<n> in the
  output, where I<n> is a numeric suffix.  Will return a list of strings
  in a list context.
  
  =back
  
  =head2 Configuration Variables or Methods
  
  Several configuration variables can be used to control the kind of output
  generated when using the procedural interface.  These variables are usually
  C<local>ized in a block so that other parts of the code are not affected by
  the change.
  
  These variables determine the default state of the object created by calling
  the C<new> method, but cannot be used to alter the state of the object
  thereafter.  The equivalent method names should be used instead to query
  or set the internal state of the object.
  
  The method forms return the object itself when called with arguments,
  so that they can be chained together nicely.
  
  =over 4
  
  =item *
  
  $Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)
  
  Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
  spews output without any newlines, indentation, or spaces between list items.
  It is the most compact format possible that can still be called valid perl.
  Style 1 outputs a readable form with newlines but no fancy indentation (each
  level in the structure is simply indented by a fixed amount of whitespace).
  Style 2 (the default) outputs a very readable form which lines up the hash
  keys.  Style 3 is like style 2, but also annotates the elements of arrays with
  their index (but the comment is on its own line, so array output consumes
  twice the number of lines).  Style 2 is the default.
  
  =item *
  
  $Data::Dumper::Trailingcomma  I<or>  I<$OBJ>->Trailingcomma(I<[NEWVAL]>)
  
  Controls whether a comma is added after the last element of an array or
  hash. Even when true, no comma is added between the last element of an array
  or hash and a closing bracket when they appear on the same line. The default
  is false.
  
  =item *
  
  $Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)
  
  Controls the degree to which the output can be C<eval>ed to recreate the
  supplied reference structures.  Setting it to 1 will output additional perl
  statements that will correctly recreate nested references.  The default is
  0.
  
  =item *
  
  $Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)
  
  Specifies the string that will be prefixed to every line of the output.
  Empty string by default.
  
  =item *
  
  $Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)
  
  Contains the prefix to use for tagging variable names in the output. The
  default is "VAR".
  
  =item *
  
  $Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)
  
  When set, enables the use of double quotes for representing string values.
  Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
  characters will be backslashed, and unprintable characters will be output as
  quoted octal integers.  The default is 0.
  
  =item *
  
  $Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)
  
  When set, Data::Dumper will emit single, non-self-referential values as
  atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
  will be avoided where possible, but be advised that such output may not
  always be parseable by C<eval>.
  
  =item *
  
  $Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will invoke that method via the object before attempting to
  stringify it.  This method can alter the contents of the object (if, for
  instance, it contains data allocated from C), and even rebless it in a
  different package.  The client is responsible for making sure the specified
  method can be called via the object, and that the object ends up containing
  only perl data types after the method has been called.  Defaults to an empty
  string.
  
  If an object does not support the method specified (determined using
  UNIVERSAL::can()) then the call will be skipped.  If the method dies a
  warning will be generated.
  
  =item *
  
  $Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will emit a method call for any objects that are to be dumped
  using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
  the method specified will have to perform any modifications required on the
  object (like creating new state within it, and/or reblessing it in a
  different package) and then return it.  The client is responsible for making
  sure the method can be called via the object, and that it returns a valid
  object.  Defaults to an empty string.
  
  =item *
  
  $Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)
  
  Can be set to a boolean value to enable deep copies of structures.
  Cross-referencing will then only be done when absolutely essential
  (i.e., to break reference cycles).  Default is 0.
  
  =item *
  
  $Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are quoted.
  A defined false value will avoid quoting hash keys when it looks like a simple
  string.  Default is 1, which will always enclose hash keys in quotes.
  
  =item *
  
  $Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)
  
  Can be set to a string that specifies an alternative to the C<bless>
  builtin operator used to create objects.  A function with the specified
  name should exist, and should accept the same arguments as the builtin.
  Default is C<bless>.
  
  =item *
  
  $Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)
  
  Can be set to a string that specifies the separator between hash keys
  and values. To dump nested hash, array and scalar values to JavaScript,
  use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
  is left as an exercise for the reader.
  A function with the specified name exists, and accepts the same arguments
  as the builtin.
  
  Default is: C< =E<gt> >.
  
  =item *
  
  $Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  we don't venture into a structure.  Has no effect when
  C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
  want to see more than enough).  Default is 0, which means there is
  no maximum depth.
  
  =item *
  
  $Data::Dumper::Maxrecurse  I<or>  $I<OBJ>->Maxrecurse(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  recursion into a structure will throw an exception.  This is intended
  as a security measure to prevent perl running out of stack space when
  dumping an excessively deep structure.  Can be set to 0 to remove the
  limit.  Default is 1000.
  
  =item *
  
  $Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)
  
  Can be set to a boolean value which controls whether the pure Perl
  implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
  a dual implementation, with almost all functionality written in both
  pure Perl and also in XS ('C'). Since the XS version is much faster, it
  will always be used if possible. This option lets you override the
  default behavior, usually for testing purposes only. Default is 0, which
  means the XS implementation will be used if possible.
  
  =item *
  
  $Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are dumped in
  sorted order. A true value will cause the keys of all hashes to be
  dumped in Perl's default sort order. Can also be set to a subroutine
  reference which will be called for each hash that is dumped. In this
  case C<Data::Dumper> will call the subroutine once for each hash,
  passing it the reference of the hash. The purpose of the subroutine is
  to return a reference to an array of the keys that will be dumped, in
  the order that they should be dumped. Using this feature, you can
  control both the order of the keys, and which keys are actually used. In
  other words, this subroutine acts as a filter by which you can exclude
  certain keys from being dumped. Default is 0, which means that hash keys
  are not sorted.
  
  =item *
  
  $Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether code references are
  turned into perl source code. If set to a true value, C<B::Deparse>
  will be used to get the source of the code reference. In older versions,
  using this option imposed a significant performance penalty when dumping
  parts of a data structure other than code references, but that is no
  longer the case.
  
  Caution : use this option only if you know that your coderefs will be
  properly reconstructed by C<B::Deparse>.
  
  =item *
  
  $Data::Dumper::Sparseseen I<or>  $I<OBJ>->Sparseseen(I<[NEWVAL]>)
  
  By default, Data::Dumper builds up the "seen" hash of scalars that
  it has encountered during serialization. This is very expensive.
  This seen hash is necessary to support and even just detect circular
  references. It is exposed to the user via the C<Seen()> call both
  for writing and reading.
  
  If you, as a user, do not need explicit access to the "seen" hash,
  then you can set the C<Sparseseen> option to allow Data::Dumper
  to eschew building the "seen" hash for scalars that are known not
  to possess more than one reference. This speeds up serialization
  considerably if you use the XS implementation.
  
  Note: If you turn on C<Sparseseen>, then you must not rely on the
  content of the seen hash since its contents will be an
  implementation detail!
  
  =back
  
  =head2 Exports
  
  =over 4
  
  =item Dumper
  
  =back
  
  =head1 EXAMPLES
  
  Run these code snippets to get a quick feel for the behavior of this
  module.  When you are through with these examples, you may want to
  add or change the various configuration variables described above,
  to see their behavior.  (See the testsuite in the Data::Dumper
  distribution for more examples.)
  
  
      use Data::Dumper;
  
      package Foo;
      sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};
  
      package Fuz;                       # a weird REF-REF-SCALAR object
      sub new {bless \($_ = \ 'fu\'z'), $_[0]};
  
      package main;
      $foo = Foo->new;
      $fuz = Fuz->new;
      $boo = [ 1, [], "abcd", \*foo,
               {1 => 'a', 023 => 'b', 0x45 => 'c'},
               \\"p\q\'r", $foo, $fuz];
  
      ########
      # simple usage
      ########
  
      $bar = eval(Dumper($boo));
      print($@) if $@;
      print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
  
      $Data::Dumper::Terse = 1;        # don't output names where feasible
      $Data::Dumper::Indent = 0;       # turn off all pretty print
      print Dumper($boo), "\n";
  
      $Data::Dumper::Indent = 1;       # mild pretty print
      print Dumper($boo);
  
      $Data::Dumper::Indent = 3;       # pretty print with array indices
      print Dumper($boo);
  
      $Data::Dumper::Useqq = 1;        # print strings in double quotes
      print Dumper($boo);
  
      $Data::Dumper::Pair = " : ";     # specify hash key/value separator
      print Dumper($boo);
  
  
      ########
      # recursive structures
      ########
  
      @c = ('c');
      $c = \@c;
      $b = {};
      $a = [1, $b, $c];
      $b->{a} = $a;
      $b->{b} = $a->[1];
      $b->{c} = $a->[2];
      print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
  
  
      $Data::Dumper::Purity = 1;         # fill in the holes for eval
      print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
  
  
      $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
  
      $Data::Dumper::Purity = 0;         # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
      ########
      # deep structures
      ########
  
      $a = "pearl";
      $b = [ $a ];
      $c = { 'b' => $b };
      $d = [ $c ];
      $e = { 'd' => $d };
      $f = { 'e' => $e };
      print Data::Dumper->Dump([$f], [qw(f)]);
  
      $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
      print Data::Dumper->Dump([$f], [qw(f)]);
  
  
      ########
      # object-oriented usage
      ########
  
      $d = Data::Dumper->new([$a,$b], [qw(a b)]);
      $d->Seen({'*c' => $c});            # stash a ref without printing it
      $d->Indent(3);
      print $d->Dump;
      $d->Reset->Purity(0);              # empty the seen cache
      print join "----\n", $d->Dump;
  
  
      ########
      # persistence
      ########
  
      package Foo;
      sub new { bless { state => 'awake' }, shift }
      sub Freeze {
          my $s = shift;
          print STDERR "preparing to sleep\n";
          $s->{state} = 'asleep';
          return bless $s, 'Foo::ZZZ';
      }
  
      package Foo::ZZZ;
      sub Thaw {
          my $s = shift;
          print STDERR "waking up\n";
          $s->{state} = 'awake';
          return bless $s, 'Foo';
      }
  
      package main;
      use Data::Dumper;
      $a = Foo->new;
      $b = Data::Dumper->new([$a], ['c']);
      $b->Freezer('Freeze');
      $b->Toaster('Thaw');
      $c = $b->Dump;
      print $c;
      $d = eval $c;
      print Data::Dumper->Dump([$d], ['d']);
  
  
      ########
      # symbol substitution (useful for recreating CODE refs)
      ########
  
      sub foo { print "foo speaking\n" }
      *other = \&foo;
      $bar = [ \&other ];
      $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
      $d->Seen({ '*foo' => \&foo });
      print $d->Dump;
  
  
      ########
      # sorting and filtering hash keys
      ########
  
      $Data::Dumper::Sortkeys = \&my_filter;
      my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
      my $bar = { %$foo };
      my $baz = { reverse %$foo };
      print Dumper [ $foo, $bar, $baz ];
  
      sub my_filter {
          my ($hash) = @_;
          # return an array ref containing the hash keys to dump
          # in the order that you want them to be dumped
          return [
            # Sort the keys of %$foo in reverse numeric order
              $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
            # Only dump the odd number keys of %$bar
              $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
            # Sort keys in default order for all other hashes
              (sort keys %$hash)
          ];
      }
  
  =head1 BUGS
  
  Due to limitations of Perl subroutine call semantics, you cannot pass an
  array or hash.  Prepend it with a C<\> to pass its reference instead.  This
  will be remedied in time, now that Perl has subroutine prototypes.
  For now, you need to use the extended usage form, and prepend the
  name with a C<*> to output it as a hash or array.
  
  C<Data::Dumper> cheats with CODE references.  If a code reference is
  encountered in the structure being processed (and if you haven't set
  the C<Deparse> flag), an anonymous subroutine that
  contains the string '"DUMMY"' will be inserted in its place, and a warning
  will be printed if C<Purity> is set.  You can C<eval> the result, but bear
  in mind that the anonymous sub that gets created is just a placeholder.
  Even using the C<Deparse> flag will in some cases produce results that
  behave differently after being passed to C<eval>; see the documentation
  for L<B::Deparse>.
  
  SCALAR objects have the weirdest looking C<bless> workaround.
  
  =head2 NOTE
  
  Different runs of Perl will have different
  ordering of hash keys.  The change was done for greater security,
  see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
  different runs of Perl will have different Data::Dumper outputs if
  the data contains hashes.  If you need to have identical Data::Dumper
  outputs from different runs of Perl, use the environment variable
  PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
  the old (platform-specific) ordering: an even prettier solution might
  be to use the C<Sortkeys> filter of Data::Dumper.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy        gsar@activestate.com
  
  Copyright (c) 1996-2019 Gurusamy Sarathy. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 VERSION
  
  Version 2.183
  
  =head1 SEE ALSO
  
  perl(1)
  
  =cut
X86_64-LINUX_DATA_DUMPER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

## no critic (ControlStructures::ProhibitPostfixControls)
## no critic (ValuesAndExpressions::ProhibitConstantPragma)
use strict;
use warnings;
use open ':std', IO => ':encoding(UTF-8)';

# ABSTRACT: Read .env file and turn its content into environment variables for different shells.

# PODNAME: envdot

our $VERSION = '0.014'; # VERSION: generated by DZP::OurPkgVersion

use English      qw( -no_match_vars );                   # Avoids regex performance penalty in perl 5.18 and earlier
use Getopt::Long qw( :config auto_version auto_help );
use Carp;
use Errno;
use Pod::Usage;

use Env::Dot::Functions       qw(:all);
use Env::Dot::ScriptFunctions qw( convert_variables_into_commands );

local $OUTPUT_AUTOFLUSH = 1;

use constant {
    DEFAULT_OPTION_DOTENV_FILENAME => '.env',
    DEFAULT_OPTION_SHELL           => q{sh},
    DEFAULT_OPTION_READ_FROM_STDIN => 0,
    EXIT_SUCCESS                   => 0,
    EXIT_ERROR_NO_FILE             => ( exists &Errno::ENOENT ? Errno::ENOENT : 255 ),
    EXIT_ERROR_OTHER_ERROR         => ( exists &Errno::EINVAL ? Errno::EINVAL : 255 ),
};

my %SHELL_ALTERNATIVES = (
    sh   => 'sh',
    bash => 'sh',
    dash => 'sh',
    ksh  => 'sh',
    csh  => 'csh',
    tcsh => 'csh',
    fish => 'fish',
);

my $man             = 0;
my $export          = 1;
my $shell           = $SHELL_ALTERNATIVES{ $ENV{SHELL} } // DEFAULT_OPTION_SHELL;
my $dotenv_filepath = DEFAULT_OPTION_DOTENV_FILENAME;
my $read_from_stdin = DEFAULT_OPTION_READ_FROM_STDIN;
GetOptions(
    'man'        => \$man,
    'export!'    => \$export,
    'shell|s=s'  => \$shell,
    'dotenv|e=s' => \$dotenv_filepath,
    ''           => \$read_from_stdin,    ## no critic (ValuesAndExpressions::ProhibitEmptyQuotes)
) or pod2usage(2);
pod2usage( -exitval => 0, -verbose => 2 ) if $man;

sub main {
    my $var_name = get_envdot_filepaths_var_name();
    my @dotenv_filepaths;
    if ( exists $ENV{$var_name} ) {
        @dotenv_filepaths = interpret_dotenv_filepath_var( $ENV{$var_name} );
    }
    elsif ($read_from_stdin) {
        croak 'Error: Option not implemented';
    }
    else {
        if ( !-f $dotenv_filepath ) {
            print {*STDERR} "Error: File not found: '$dotenv_filepath'\n"
              or croak 'Cannot print error message';
            return EXIT_ERROR_NO_FILE;
        }
        @dotenv_filepaths = ($dotenv_filepath);    # The CLI parameter
    }

    my @vars;
    foreach my $dotenv_filepath ( reverse @dotenv_filepaths ) {
        local $EVAL_ERROR = undef;
        my @these_vars;
        eval { @these_vars = get_dotenv_vars($dotenv_filepath); 1; } or do {
            my $e = $EVAL_ERROR;
            my ( $err, $l, $fp ) = extract_error_msg($e);
            print {*STDERR} 'Error: ' . $err . ( $l ? qq{ line $l} : q{} ) . ( $fp ? qq{ file '$fp'} : q{} ) . "\n"
              or croak 'Cannot print error message';
            return EXIT_ERROR_OTHER_ERROR;
        };
        push @vars, @these_vars;
    }
    $_->{'opts'}->{'export'} = $export foreach (@vars);

    print {*STDOUT} convert_variables_into_commands( $shell, @vars )
      or croak 'Cannot print variables to STDOUT';

    return EXIT_SUCCESS;
}

exit main(@ARGV);

__END__

=pod

=encoding UTF-8

=head1 NAME

envdot - Read .env file and turn its content into environment variables for different shells.

=head1 VERSION

version 0.014

=head1 SYNOPSIS

envdot [options]

    eval `envdot`

Options:
    --help
    --man
    --version
    --export --no-export
    --shell -s
    --dotenv -e

=head2 CLI interface without dependencies

The F<envdot> command is also available
as a self contained executable.
You can download it and run it as it is without
additional installation of CPAN packages.
Of course, you still need Perl, but Perl comes with any
normal Linux installation.

This can be convenient if you want to, for instance,
include F<envdot> in a docker container build.

    curl -LSs -o envdot https://raw.githubusercontent.com/mikkoi/env-dot/main/envdot.self-contained
    chmod +x ./envdot

=head1 DESCRIPTION

B<envdot> reads your F<.env> file and converts it
into environment variable commands suitable for
different shells (shell families): B<sh>, B<csh> and B<fish>.

F<.env> files can be written in different flavors.
B<envdot> supports the often used B<sh> compatible flavor and
the B<docker> flavor which are not compatible with each other.

If you have several F<.env> files, you can read them in at one go
with the help of the environment variable B<ENVDOT_FILEPATHS>.
Separate the full paths with 'B<:>' character.

Env::Dot will load the files in the B<reverse order>,
starting from the last. This is the same ordering as used in B<PATH> variable:
the first overrules the following ones, that is, when reading from the last path
to the first path, if same variable is present in more than one file, the later
one replaces the one already read.

If you have set the variable ENVDOT_FILEPATHS, then B<envdot> will use that.
Otherwise, it uses the command line parameter.
If no parameter, then default value is used. Default is the file
F<.env> in the current directory.

=head1 NAME

envdot - Read .env file and turn its content into environment variables for different shells.

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--version>

Prints the version and exits.

=item B<--export>, B<--no-export>

Write commands to set variables for local shell or for exporting them.
You usually want to export the variables
to all subsequent programs and subshells, i.e.
make them into I<environment variables>.

Default: export

=item B<-s>, B<--shell>

Which shell (family) are you using? Supported: sh, csh, fish.

Default: sh

=item B<-e>, B<--dotenv>

Path to F<.env> file.

Default: current directory F<.env>

=back

=head1 EXAMPLES

    eval `envdot --no-export --shell csh`

    eval `envdot --dotenv subdir/.env`

    ENVDOT_FILEPATHS='../.env:subdir/.env:.env' eval `envdot`

=head1 DEPENDENCIES

No external dependencies outside Perl's standard distribution.

=head1 SEE ALSO

L<Env::Assert> will verify that you certainly have those environmental
variables you need. It also has an executable which can, for example,
be used to perform the check in the beginning of a B<docker> container run.

L<Dotenv> is another package which implements functionality to use
F<.env> files in Perl.

L<shdotenv|https://github.com/ko1nksm/shdotenv> is a project to provide dotenv
for shells with support for POSIX-compliant and multiple .env file syntax.

=head1 AUTHOR

Mikko Koivunalho <mikkoi@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2023 by Mikko Koivunalho.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
