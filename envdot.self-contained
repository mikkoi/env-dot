
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Env/Dot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot;
  use strict;
  use warnings;
  use 5.010;
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from .env file
  
  our $VERSION = '0.020';
  
  # We define our own import routine because
  # this is the point (when `use Env::Dot` is called)
  # when we do our magic.
  
  {
      no warnings 'redefine';    ## no critic [TestingAndDebugging::ProhibitNoWarnings]
  
      sub import {
          my ($class, $cmd, $args) = @_;
  
          # We also allow only: 'use Env::Dot;'
          croak "Unknown argument '$cmd'" if( $cmd && $cmd ne 'read' );
  
          if( ! load_vars( %{ $args // {} } ) ) {
              croak 'Errors in environment detected.';
          }
          return;
      }
  }
  
  use Env::Dot::Functions qw(
      get_dotenv_vars
      interpret_dotenv_filepath_var
      get_envdot_filepaths_var_name
      extract_error_msg
      create_error_msg
  );
  
  use constant {
      OPTION_FILE_TYPE         => q{file:type},
      OPTION_FILE_TYPE_PLAIN   => q{plain},
      OPTION_FILE_TYPE_SHELL   => q{shell},
      DEFAULT_OPTION_FILE_TYPE => q{shell},
      DEFAULT_ENVDOT_FILEPATHS => q{.env},
      INDENT                   => q{    },
  };
  
  =pod
  
  =head1 STATUS
  
  This module is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
  =for test_synopsis BEGIN { die 'SKIP: no .env file here' }
  
      # If your dotenv file is `.env`:
      use Env::Dot;
      # or
      use Env::Dot 'read';
  
      print $ENV{'VAR_DEFINED_IN_DOTENV_FILE'};
  
      # If you have a dotenv file in a different filepath:
      use Env::Dot read => {
          dotenv_file => '/other/path/my_environment.env',
      };
  
  =head1 DESCRIPTION
  
  More flexibility in how you manage and use your F<.env> file.
  
  =for stopwords dotenv
  
  B<Attn. Existing environment variables always take precedence to dotenv variables!>
  A dotenv variable (variable from a file) does not overwrite
  an existing environment variable. This is by design because
  a dotenv file is to augment the environment, not to replace it.
  
  This means that you can override a variable in `.env` file by creating
  its counterpart in the environment. For instance:
  
      unset VAR
      echo "VAR='Good value'" >> .env
      perl -e 'use Env::Dot; print "VAR:$ENV{VAR}\n";'
      # VAR:Good value
      VAR='Better value'; export VAR
      perl -e 'use Env::Dot; print "VAR:$ENV{VAR}\n";'
      # VAR:Better value
  
  =head2 Features
  
  =over 8
  
  =item If no B<.env> file is present, then do nothing
  
  By default, Env::Dot will do nothing if there is no
  B<.env> file.
  You can also configure Env::Dot to emit an alarm
  or break execution, if you want.
  
  =item Specify other dotenv files with path
  
  If your B<.env> file is located in another path,
  not the current working directory,
  you can use the environment variable
  B<ENVDOT_FILEPATHS> to tell where your dotenv file is located.
  You can specify several file paths; just separate
  them by B<:>. Env::Dot will load the files in the B<reverse order>,
  starting from the last. This is the same ordering as used in B<PATH> variable:
  the first overrules the following ones, that is, when reading from the last path
  to the first path, if same variable is present in more than one file, the later
  one replaces the one already read.
  
  Attn. If you are using Windows, separate the paths by <;>!
  
  For example, if you have the following directory structure:
  
      project-root
      | .env
      + - sub-project
        | .env
  
  and you specify B<ENVDOT_FILEPATHS=project-root/sub-project/.env:project-root/.env>,
  then the variables in file B<project-root/.env> will get replaced
  by the more specific variables in B<project-root/sub-project/.env>.
  
  In Windows, this would be B<ENVDOT_FILEPATHS=project-root\sub-project\.env;project-root\.env>
  
  N.B. The ordering has changed in version 0.0.9.
  
  =item Support different types of .env files
  
  =for stopwords dotenv
  
  Unix Shell I<source> command compatible dotenv files use double or single quotation marks
  (B<"> or B<'>) to define a variable which has spaces. But, for instance,
  Docker compatible F<.env> files do not use quotation marks. The variable's
  value begins with B<=> sign and ends with linefeed.
  
  =for stopwords dotenv
  
  You can specify in the dotenv file itself - by using meta commands -
  which type of file it is.
  
  =for stopwords envdot
  
  =item Use executable B<envdot> to bring the variables into your shell
  
  The executable is distributed together with Env::Dot package.
  It is in the directory I<script>.
  
  =for stopwords envdot
  
  The executable I<script/envdot> is not Windows compatible!
  
  =for stopwords Powershell envdot
  
  A Windows (MS Command and Powershell compatible) version, I<script\envdot.bat>, is possible
  in a future release. Please contact the author if you are interested in it.
  
      eval "$(envdot)"
  
  N.B. If your B<.env> file(s) contain variables which need interpolating,
  for example, to combine their value from other variables or execute a command
  to produce their value, you have to use the B<envdot> program.
  B<Env::Dot> does not do any interpolating. It cannot because that would involve
  running the variable in the shell context.
  
  =back
  
  =for stopwords DotEnv Powershell dotenv env envdot shdotenv
  
  =head2 DotEnv File Meta Commands
  
  The B<var:> commands affect only the subsequent variable definition.
  If there is another B<envdot> command, the second overwrites the first
  and default values are applied again.
  
  =over 8
  
  =item read:from_parent
  
  By setting this option to B<true>, B<Env::Dot> or B<envdot> command
  will search for F<.env> files in the file system tree upwards.
  It will load the first F<.env> file it finds from
  the current directory upwards to root.
  
  Using B<read:from_parent> will only find and read
  one B<.env> file in a parent directory.
  If you want to chain the B<.env> files,
  they all must set B<read:from_parent> - except the top one.
  
  This functionality can be useful in situations where you have
  parallel projects which share common environment variables
  in one F<.env> file in a parent directory.
  
  If there is no parent F<.env> file, Env::Dot will break execution
  and give an error.
  
  By default this setting is off.
  
  =item read:allow_missing_parent
  
  When using option B<read:from_parent>, if the parent F<.env> file does not exist,
  by default Env::Dot will emit an error and break execution.
  In some situations, it might be normal that a parent F<.env> file
  could be missing. Turn on option B<read:allow_missing_parent> if you
  do not want an error in that case.
  
  By default this setting is off.
  
  =item file:type
  
  Changes how B<Env::Dot> reads lines below from this commands. Default is:
  
      # envdot (file:type=shell)
      VAR="value"
  
  Other possible value of B<file:type> is:
  
      # envdot (file:type=plain)
      VAR=My var value
  
  =item var:allow_interpolate
  
  By default, when writing variable definitions for the shell,
  every variable is treated as static and surrounded with
  single quotation marks B<'> in Unix shell which means
  shell will read the variable content as is.
  By setting this to B<1> or B<true>, you allow shell
  to interpolate.
  This meta command is only useful when running B<envdot> command
  to create variable definitions for B<eval> command to read.
  
      # envdot (var:allow_interpolate)
      DYNAMIC_VAR="$(pwd)/${ANOTHER_VAR}"
  
  =back
  
  =head1 DEPENDENCIES
  
  No external dependencies outside Perl's standard distribution.
  
  =head1 FUNCTIONS
  
  No functions exported to the calling namespace.
  
  =head2 load_vars
  
  Load variables from F<.env> file or files in environment variable
  B<ENVDOT_FILEPATHS>.
  
  =cut
  
  sub load_vars {
      my (%args) = @_;
      my %allowed_args = ('dotenv_file' => 1, );
      foreach my $arg (keys %args) {
          croak "Illegal argument '$arg'" if (!exists $allowed_args{$arg});
      }
      my @dotenv_filepaths;
      if ( $args{'dotenv_file'} ) {
          @dotenv_filepaths = ($args{'dotenv_file'});
      } elsif ( exists $ENV{ get_envdot_filepaths_var_name() } ) {
          @dotenv_filepaths = interpret_dotenv_filepath_var( $ENV{ get_envdot_filepaths_var_name() } );
      } else {
          if ( -f DEFAULT_ENVDOT_FILEPATHS ) {
              @dotenv_filepaths = (DEFAULT_ENVDOT_FILEPATHS);    # The CLI parameter
          }
      }
  
      my @vars;
      eval { @vars = get_dotenv_vars(@dotenv_filepaths); 1; } or do {
          my $e = $EVAL_ERROR;
          my ($err, $l, $fp) = extract_error_msg($e);
          croak 'Error: ' . $err . ($l ? qq{ line $l} : q{}) . ($fp ? qq{ file '$fp'} : q{})
      };
      my %new_env;
  
      # Populate new env with the dotenv variables.
      foreach my $var (@vars) {
          $new_env{ $var->{'name'} } = $var->{'value'};
      }
      foreach my $var_name ( sort keys %ENV ) {
          $new_env{$var_name} = $ENV{$var_name};
      }
  
      # We need to replace the current %ENV, not change individual values.
      ## no critic [Variables::RequireLocalizedPunctuationVars]
      %ENV = %new_env;
      return \%ENV;
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Env::Assert> will verify that you certainly have those environmental
  variables you need. It also has an executable which can, for example,
  perform the check in the beginning of a B<docker> container run.
  
  L<Dotenv> and L<ENV::Util|https://metacpan.org/pod/ENV::Util>
  are packages which also implement functionality to use
  F<.env> files in Perl.
  
  L<Config::ENV> and L<Config::Layered::Source::ENV> provide other means
  to configure application with the help of environment variables.
  
  =for stopwords dotenv shdotenv
  
  L<shdotenv|https://github.com/ko1nksm/shdotenv> is a project to provide dotenv
  for shells with support for POSIX-compliant and multiple .env file syntax.
  
  =cut
ENV_DOT

$fatpacked{"Env/Dot/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT_FUNCTIONS';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot::Functions;
  use strict;
  use warnings;
  use 5.010;
  
  =for :stopwords env dotenv filepath filepaths
  
  =cut
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
      get_dotenv_vars
      interpret_dotenv_filepath_var
      get_envdot_filepaths_var_name
      extract_error_msg
      create_error_msg
  );
  our %EXPORT_TAGS = (
      'all' => [
          qw(
              get_dotenv_vars
              interpret_dotenv_filepath_var
              get_envdot_filepaths_var_name
              extract_error_msg
              create_error_msg
          )
      ],
  );
  
  use Cwd qw( abs_path );
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use File::Spec;
  use IO::File;
  use Carp;
  
  
  # ABSTRACT: Read environment variables from a .env file
  
  our $VERSION = '0.020';
  
  use constant {
      OPTION_FILE_TYPE                         => q{file:type},
      OPTION_FILE_TYPE_PLAIN                   => q{plain},
      OPTION_FILE_TYPE_SHELL                   => q{shell},
      DEFAULT_OPTION_FILE_TYPE                 => q{shell},
      OPTION_READ_FROM_PARENT                  => q{read:from_parent},
      DEFAULT_OPTION_READ_FROM_PARENT          => 0,
      OPTION_READ_ALLOW_MISSING_PARENT         => q{read:allow_missing_parent},
      DEFAULT_OPTION_READ_ALLOW_MISSING_PARENT => 0,
  };
  
  my %DOTENV_OPTIONS = (
      OPTION_READ_FROM_PARENT()          => 1,
      OPTION_READ_ALLOW_MISSING_PARENT() => 1,
      'file:type'                        => 1,
      'var:allow_interpolate'            => 1,
  );
  my %DOS_PLATFORMS = (
          'dos'     => 'MS-DOS/PC-DOS',
          'os2'     => 'OS/2',
          'MSWin32' => 'Windows',
          'cygwin'  => 'Cygwin',
      );
  
  =head1 STATUS
  
  This module is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot::Functions qw( get_dotenv_vars interpret_dotenv_filepath_var );
      # or
      use Env::Dot::Functions ':all';
  
  =head1 DESCRIPTION
  
  =for stopwords envdot
  
  This package just contains functions for use
  in the main package L<Env::Dot> and in
  the command line tool B<envdot>.
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 get_dotenv_vars(@)
  
  =for stopwords env
  
  Return all variables from the F<.env> file
  as a list of hashes (name/value pairs).
  This list is created in the same order the variables
  are read from the files and may therefore contain
  the same variable several times.
  
  The files, however, are read in reversed order, just like
  paths in variable B<PATH> are used.
  
  Arguments:
  
  =over 8
  
  =item * filepaths, list of dotenv filepaths.
  
  =back
  
  If a file does not exist, we break the execution.
  
  =cut
  
  sub get_dotenv_vars {
      my (@dotenv_filepaths) = @_;
  
      my @vars;
      foreach my $filepath ( reverse @dotenv_filepaths ) {
          if ( -f $filepath ) {
              push @vars, _read_dotenv_file_recursively($filepath);
          }
          else {
              my ($err) = "File not found: '$filepath'";
              croak create_error_msg($err);
          }
      }
      return @vars;
  }
  
  =head2 interpret_dotenv_filepath_var( $filepaths )
  
  Return a list of file paths.
  
  =cut
  
  sub interpret_dotenv_filepath_var {
      my ($var_content) = @_;
      if( exists $DOS_PLATFORMS{ $OSNAME } ) {
          return split qr{;}msx, $var_content;
      } else {
          return split qr{:}msx, $var_content;
      }
  }
  
  =head2 get_envdot_filepaths_var_name
  
  =for stopwords env
  
  Return the name of the environment variable
  which user can use to specify the paths of .env files.
  
  =cut
  
  sub get_envdot_filepaths_var_name {
      return q{ENVDOT_FILEPATHS};
  }
  
  # Private subroutines
  
  sub _read_dotenv_file_recursively {
      my ($filepath) = @_;
      $filepath = abs_path($filepath);
      my @rows       = _read_dotenv_file($filepath);
      my %r          = _interpret_dotenv($filepath, @rows);
      my @these_vars = @{ $r{'vars'} };
      if ( $r{'opts'}->{ OPTION_READ_FROM_PARENT() } ) {
          my $parent_filepath = _get_parent_dotenv_filepath($filepath);
          if ($parent_filepath) {
              unshift @these_vars, _read_dotenv_file_recursively($parent_filepath);
          }
          elsif ( !$r{'opts'}->{ OPTION_READ_ALLOW_MISSING_PARENT() } ) {
              my ($err) = "No parent .env file found for child file '$filepath'";
              croak create_error_msg($err);
          }
      }
      return @these_vars;
  }
  
  # Follow directory hierarchy upwards until you find a .env file.
  # If you don't, return undef.
  # Otherwise return the path.
  sub _get_parent_dotenv_filepath {
      my ($current_filepath) = @_;
  
      my ($volume, $directories) = File::Spec->splitpath($current_filepath);
      my $parent_path = File::Spec->catpath($volume, $directories);
      my $parent_filepath;
  
      while( defined $parent_path && $parent_path ne File::Spec->rootdir() ) {
          $parent_path     = abs_path(File::Spec->catdir($parent_path, File::Spec->updir));
          $parent_filepath = File::Spec->catfile($parent_path, '.env' );
          return $parent_filepath if( defined $parent_path && -f $parent_filepath );
      }
      return;
  }
  
  sub _interpret_dotenv {
      my ($fp, @rows) = @_;
      my %options = (
          OPTION_READ_FROM_PARENT()          => DEFAULT_OPTION_READ_FROM_PARENT,
          OPTION_READ_ALLOW_MISSING_PARENT() => DEFAULT_OPTION_READ_ALLOW_MISSING_PARENT,
          'file:type'                        => DEFAULT_OPTION_FILE_TYPE,
          'var:allow_interpolate'            => 0,
      );    # Options related to reading the file. Applied as they are read.
      my @vars;
      my $row_num = 1;
      foreach (@rows) {
          ## no critic (ControlStructures::ProhibitCascadingIfElse)
          ## no critic (RegularExpressions::ProhibitComplexRegexes)
          if (
              # This is envdot meta command
              # The var:<value> options can only apply to one subsequent var row.
              m{
              ^ [[:space:]]{0,} [#]{1}
              [[:space:]]{1,} envdot [[:space:]]{1,}
              [(] (?<opts> [^)]{0,}) [)]
              [[:space:]]{0,} $
              }msx
            )
          {
              my $opts = _interpret_opts( $LAST_PAREN_MATCH{opts} );
              foreach my $key ( keys %{$opts} ) {
                  if ( !exists $DOTENV_OPTIONS{$key} ) {
                      my $err = "Unknown envdot option: '$key'";
                      croak create_error_msg( $err, $row_num, $fp );
                  }
              }
              $options{'var:allow_interpolate'} = 0;
              foreach ( keys %{$opts} ) {
                  $options{$_} = $opts->{$_};
              }
          }
          elsif (
              # This is comment row
              m{
                  ^ [[:space:]]{0,} [#]{1} .* $
              }msx
            )
          {
              1;
          }
          elsif (
              # This is empty row
              m{
                  ^ [[:space:]]{0,} $
              }msx
            )
          {
              1;
          }
          elsif (
              # This is env var description
              m{
                  ^ (?<name> [^=]{1,}) = (?<value> .*) $
              }msx
            )
          {
              my ( $name, $value ) = ( $LAST_PAREN_MATCH{name}, $LAST_PAREN_MATCH{value} );
              if ( $options{'file:type'} eq OPTION_FILE_TYPE_SHELL ) {
                  if (
                      $value =~ m{
                      ^
                      ['"]{1} (?<value> .*) ["']{1}  # Get value from between quotes
                      (?: [;] [[:space:]]{0,} export [[:space:]]{1,} $name)?  # optional
                      [[:space:]]{0,}  # optional whitespace at the end
                      $
                  }msx
                    )
                  {
                      ($value) = $LAST_PAREN_MATCH{value};
                  }
  
                  # "export" can also be at the start. Only for TYPE_SHELL
                  if ( $name =~ m{^ [[:space:]]{0,} export [[:space:]]{1,} }msx ) {
                      $name =~ m{
                          ^
                          [[:space:]]{0,} export [[:space:]]{1,} (?<name> .*)
                          $
                      }msx;
                      $name = $LAST_PAREN_MATCH{name};
                  }
              }
              elsif ( $options{'file:type'} eq OPTION_FILE_TYPE_PLAIN ) {
                  1;  # document no-operation
              }
              my %opts = ( allow_interpolate => $options{'var:allow_interpolate'}, );
              push @vars, { name => $name, value => $value, opts => \%opts, };
              $options{'var:allow_interpolate'} = 0;
          }
          else {
              my $err = "Invalid line: '$_'";
              croak create_error_msg($err, $row_num, $fp);
          }
          $row_num++;
      }
      return opts => \%options, vars => \@vars;
  }
  
  sub _interpret_opts {
      my ($opts_str) = @_;
      my @opts = split qr{ [[:space:]]{0,} [,] [[:space:]]{0,} }msx, $opts_str;
      my %opts;
      foreach (@opts) {
          ## no critic (ControlStructures::ProhibitPostfixControls)
          my ( $key, $val ) = split qr/=/msx;
          $val        = $val // 1;
          $val        = 1 if ( $val eq 'true'  || $val eq 'True' );
          $val        = 0 if ( $val eq 'false' || $val eq 'False' );
          $opts{$key} = $val;
      }
      return \%opts;
  }
  
  sub _read_dotenv_file {
      my ($filepath) = @_;
      my $fh = IO::File->new();
      $fh->open(qq{< $filepath}) or croak "Error: Cannot open file '$filepath'";
      $fh->binmode(':encoding(UTF-8)');
      my @dotenv_rows = <$fh>;
      chomp @dotenv_rows;
      $fh->close or croak "Error: Cannot close file '$filepath'";
      return @dotenv_rows;
  }
  
  # Error messages:
  # Message structure:
  # <msg>! [line <num>] [file <filepath>]
  
  =head2 extract_error_msg
  
  Extract the elements of error message (exception): err, line and filepath.
  
  =cut
  
  sub extract_error_msg {
      my ($msg) = @_;
      if( ! $msg ) {
          croak 'Parameter error: missing parameter \'msg\'';
      }
      ## no critic (RegularExpressions::ProhibitComplexRegexes)
      my ($err, $line, $filepath) = $msg =~
          m/^ ([^!]{1,}) \! (?: \s line \s ([[:digit:]]{1,}) (?: \s file \s \'([^']{1,})\' )? )? .* $/msx;
      return $err, $line, $filepath;
  }
  
  =head2 create_error_msg
  
  create an error message (exception) from the three elements: err, line and filepath.
  
  =cut
  
  sub create_error_msg {
      my ($err, $line, $filepath) = @_;
      if( ! $err ) {
          croak 'Parameter error: missing parameter \'err\'';
      }
      if( ! $line && $filepath ) {
          croak 'Parameter error: missing parameter \'line\'';
      }
      return "${err}!"
          . (defined $line ? " line ${line}" : q{})
          . (defined $filepath ? " file '${filepath}'" : q{});
  }
  
  1;
ENV_DOT_FUNCTIONS

$fatpacked{"Env/Dot/ScriptFunctions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_DOT_SCRIPTFUNCTIONS';
  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  package Env::Dot::ScriptFunctions;
  use strict;
  use warnings;
  use 5.010;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
    convert_variables_into_commands
  );
  our %EXPORT_TAGS = ( 'all' => [qw( convert_variables_into_commands )], );
  
  use English qw( -no_match_vars );    # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Read environment variables from a .env file
  
  our $VERSION = '0.020';
  
  use constant {
      OPTION_FILE_TYPE         => q{file:type},
      OPTION_FILE_TYPE_PLAIN   => q{plain},
      OPTION_FILE_TYPE_SHELL   => q{shell},
      DEFAULT_OPTION_FILE_TYPE => q{shell},
  };
  
  my %DOTENV_OPTIONS = (
      'file:type'             => 1,
      'var:allow_interpolate' => 1,
  );
  
  my %VAR_OUTPUT = (
      q{sh}   => \&_convert_var_to_sh,
      q{csh}  => \&_convert_var_to_csh,
      q{fish} => \&_convert_var_to_fish,
  );
  
  =pod
  
  =for stopwords envdot env
  
  =head1 STATUS
  
  This module is currently being developed so changes in the API are possible,
  though not likely.
  
  
  =head1 SYNOPSIS
  
      use Env::Dot::ScriptFunctions qw( convert_variables_into_commands );
  
  =head1 DESCRIPTION
  
  =for stopwords envdot
  
  This package just contains functions for use
  in the main package L<Env::Dot> and in
  the command line tool B<envdot>.
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 convert_variables_into_commands()
  
  # Return all variables from the F<.env> file
  # as a list of hashes (name/value pairs).
  # This list is created in the same order the variables
  # are read from the files and may therefore contain
  # the same variable several times.
  
  =cut
  
  sub convert_variables_into_commands {
      my ( $shell, @vars ) = @_;
      my $out = q{};
      foreach my $var (@vars) {
          $out .= _convert_variable( $shell, $var );
          $out .= "\n";
      }
      return $out;
  }
  
  # Private subroutines
  
  sub _convert_variable {
      my ( $shell, $var ) = @_;
      if ( exists $VAR_OUTPUT{$shell} ) {
          return &{ $VAR_OUTPUT{$shell} }($var);
      }
      else {
          croak "Unknown shell: $shell";
      }
  }
  
  sub _convert_var_to_sh {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      if ($want_export) {
          return sprintf "%s=$quote%s$quote; export %s", $name, $value, $name;
      }
      else {
          return sprintf "%s=$quote%s$quote", $name, $value;
      }
  }
  
  sub _convert_var_to_csh {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      if ($want_export) {
          return sprintf "setenv %s $quote%s$quote", $name, $value;
      }
      else {
          return sprintf "set %s $quote%s$quote", $name, $value;
      }
  }
  
  sub _convert_var_to_fish {
      my ($var) = @_;
      my ( $name, $value, $want_export, $allow_interpolate ) =
        ( $var->{'name'}, $var->{'value'}, $var->{'opts'}->{'export'}, $var->{'opts'}->{'allow_interpolate'}, );
      my $quote = $allow_interpolate ? q{"} : q{'};
      return sprintf "set -e %s; set -x -U %s $quote%s$quote", $name, $name, $value;
  }
  
  1;
ENV_DOT_SCRIPTFUNCTIONS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

